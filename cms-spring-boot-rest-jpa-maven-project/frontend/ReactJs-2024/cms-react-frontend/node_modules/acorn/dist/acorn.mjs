// This file was generated. Do not modify manually!
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

// This file was generated. Do not modify manually!
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];

// This file was generated. Do not modify manually!
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";

// This file was generated. Do not modify manually!
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range.

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
  return false
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords[name] = new TokenType(name, options)
}

var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),
  coalesce: binop("??", 1),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}

function nextLineBreak(code, from, end) {
  if ( end === void 0 ) end = code.length;

  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next))
      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
  }
  return -1
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

var hasOwn = Object.hasOwn || (function (obj, propName) { return (
  hasOwnProperty.call(obj, propName)
); });

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

var regexpCache = Object.create(null);

function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"))
}

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    var nextBreak = nextLineBreak(input, cur, offset);
    if (nextBreak < 0) { return new Position(line, offset - cur) }
    ++line;
    cur = nextBreak;
  }
}

// A second argument must be given to configure the parser process.
// These options are recognized (only `ecmaVersion` is required):

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

var warnedAboutEcmaVersion = false;

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (!opts || opts.allowHashBang == null)
    { options.allowHashBang = options.ecmaVersion >= 14; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128,
    SCOPE_CLASS_STATIC_BLOCK = 256,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal* and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types$1.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = Object.create(null);

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;

  // The stack of private names.
  // Each element has two properties: 'declared' and 'used'.
  // When it exited from the outermost class definition, all used private names must be declared.
  this.privateNameStack = [];
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.canAwait.get = function () {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
    if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
  }
  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
};

prototypeAccessors.allowSuper.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
};

prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

prototypeAccessors.allowNewDotTarget.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
};

prototypeAccessors.inClassStaticBlock.get = function () {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
};

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp$9 = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) { return false }
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" ||
        (lineBreak.test(spaceAfter[0]) &&
         !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
    }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof ||
    this.type === types$1.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

var DestructuringErrors = function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
};

pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
};

pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$8 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$8.parseTopLevel = function(node) {
  var exports = Object.create(null);
  if (!node.body) { node.body = []; }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91 || nextCh === 92) { return true } // '[', '/'
  if (context) { return false }

  if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length ||
     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types$1._debugger: return this.parseDebuggerStatement(node)
  case types$1._do: return this.parseDoStatement(node)
  case types$1._for: return this.parseForStatement(node)
  case types$1._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types$1._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types$1._if: return this.parseIfStatement(node)
  case types$1._return: return this.parseReturnStatement(node)
  case types$1._switch: return this.parseSwitchStatement(node)
  case types$1._throw: return this.parseThrowStatement(node)
  case types$1._try: return this.parseTryStatement(node)
  case types$1._const: case types$1._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types$1._while: return this.parseWhileStatement(node)
  case types$1._with: return this.parseWithStatement(node)
  case types$1.braceL: return this.parseBlock(true, node)
  case types$1.semi: return this.parseEmptyStatement(node)
  case types$1._export:
  case types$1._import:
    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40 || nextCh === 46) // '(' or '.'
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types$1.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types$1.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR;) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty$1 = [];

pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);

  return param
};

pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$8.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) { this.strict = false; }
  this.next();
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) { break }
  }
  return node
};

pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types$1.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$8.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$8.parseClassElement  function(contstructorAllowsSuper) {
  if (this.2tement ? "Cdent)) { reme ?  }
  }

 ions.ecmaVerorOf = this.options.ecmaVeode();
  0 ) node = this.startNod } }
  eymaybeNa""od } }
 isGode.generatOf = false;
  = !!isratOf = false;
 
    kinm== "M"od } }
 isSlassSratOf = faer) {
  if (thiis.isContextslassS"ement)) {
};

// PslassSd the osed ull);
    ons.ecmaVersion fier" && this.eat(types$1.brf")))) {
      this.parseClassStaticSuper(nodeeeee }
  return );
      }
    if (thparseClassElivateNareIdecase || this.type === types$1. else {
  sSlassSrator = true;
    } else {
  eymaybeNa"slassS";    }
    }
  === nodssSrat sSlassSnode);
 ! eymaybe.keyons.ecmaVersionAwait && this.eatContextual("asysync) {
     if (thparseClassElivateNareIdecase || this.type === types$1. name && !this.canInsertSemicolon()) {   = !!isrator = true;
    } else {
  eymaybeNa"ual("a;    }
    }
 );
 ! eymaybe.ke  ons.ecmaVersion >= 6 && !isAsier" && this.eat(types$1.ysync) {
sGode.generator = tru }
 );
 ! eymaybe.ke6 && !ise.ke6 &Gode.gene; i--) {
    vstVhis.var" && this.value;
   t && this.eatContextgal("ecase || thiis.isContextsal("letent);
      if (thparseClassElivateNareIdment)) {
   
    ki vstVhis. true;
      } nt)) {
   
eymaybeNa vstVhis. true;
      }
    }
 {
};

// P var ele.key}
 );
 
eymaybment)) {
};// - '// 'gal// 'sal//  '('nodssS' wen t mayaeak = keyiven contelif any.
};
t, "as/ next tokennyrties ose witkl-cas and var ele.key.NT) {
      //uexpectef = fals [];
  nessBody = this.starAtComma(this.lastTokStart, this.lastTokStartals [];
  neslabel.n 
eymaybode();
    this.finishNode nes,e !== "Identiared");
  } else {
    pp$8.parseClassElmaybSuper(nodeemicolon()arseCGode.l3)!isrator 1ibcr59uu
    if (on ete = this.eat(types$1._else) ? this.parseSgu
   otyppess6!    } else {  ifnR, KStart,pe();
  t.type === "M;his.parsenctiosllowSuperOu{
  eu
   otyppes  if (ression")
};

pp$8.;/  '('noCouldn'Defi`for)art(identintoany.
'hNode nes,dy.bod' on ete FUNCback   /ny arlse, we eent that i eu
   otyppes  iu
    if (on ete  { break }
    }
  } element)) "u
   otyppesare'n" : "fvar/.keefin 
eymaybFUNC_HANGINGnst || isu
   otyppes?  t.type === " :1.statementfinishNode nes,dy.bod);
  this.eat(typeion = functnctiosllowSuperOuybode();
    this.finishNode nes,UNCTItiared");
  } e
    if (!this.eat(tyase || thiis.isContextspty.

var empty$1 Accessorthis.finis(statement & FUNC_STAT = function() {
  return thisp  } elseT = function() {
  return thisnumT = function() {
  return this) { ret = function() {
  return this.typketLt = function() {
rn this.
   itatement ? "ClassDeclarati  
    default vaseClassEleme| this.options.ecmaVersionp  } elsen >= 9 || this.opame) {
  rnt.type === "MethodDefi types$1._in || ment)) "ussDes.vare'n" : "fr La;
t, "as/ ndis.t.type === 'ex bindinbindiRecoverarties ose witkl-cas an }
        h' in strict m  } else if(ybode();
    this.finishNode  returtart,pull);
    ifturn this.parseE nes,dy.bod   default von etethis.eat(typeion = functnctiosllowSuperOuy  thi'noCident   ha sinthisoptions.ec   on ete    Na"slasson ete  f (element.type === "MethodDeat i erator = tru i types$1._i element)) "u
   otyppesare'n"this.;
  this.aybFUNC_HAat i else) ? ti types$1._i element)) "u
   otyppesare'n"thismentsGodon ete  onsAsVae class");on ete  else {  ifnR, KStart,pon eteth".type ===his.eatCon types$1._i element)) "ussDes.v"for-in" : "fo
  if (t>= 0)
   s/ ndi.type ===hi");
  } else {
   rseClassionsame) {
 on ete vbe.ke6 && !iif (thy.bod)is.eat(typeion = functnctiosllowSuperOuybothi'noCidentrseClassElmaon ete  f (elemenis.v{  irseClction(nwitch ?  if n destructuring patterns"); }
 rseClcment)) "is.  { should" : "fnoation assignments aon ete  f (elemenss.v{  irseClction(nwitch ?  if rn }
  if (refDestructuringErrorseClcment)) "ss.  { should" : "fexactl { teation ssignments aon ete  f (elemenss.v{  irseClction(n     true;
   RestElingComm }
  if (refDestructuringErrorseClction(n    ment)) "Ss.  { 
    { ;
  s.tration assignmde(classBody, "ClassBody")on eteth"dy.body.push(elem itatement ? "ClassDeUNCTI   default vatemesEleme| thfnR, KStart,pateme
  t.type === "Ms.eatCon types$1._iateme. element)) "ussDes.vare'n" : "frtatemeas/ ndist.type === 'ex binae class");ateme. else {  ifnR, KStart,pateme
  .type ===his.eatCon types$1._iateme. element)) "ussDes.vare'n" : "frt else {atemeas/ ndis.type ==='hi");
  } e.startNode();
    this.parseVarI'nodof a givS= thxe {
 e.st'reak`/`co'.parturneRecoveof") + " lo.his.parsesreateNewateNaindingTateclause.body =efDestassDeUNCTIIn initsreat.stassDeUNCTIIn ibody =sreat.stassDeUNCTIIn iname && !thisateme.vbe.ke6 && !iif (thht = isForIn ? t =sreat.stassDeUNCTIIn inamstassDeUNCTIIn ibody();
    this.ateme.vbe.ke6 ializati+ "' has aon(node, expde(classBody, "ClassBody")ateme
    returty.push(elem itatement ? "ClassDe& this.eat( "FunctionExpression")if ( node === vo
 // A claLart) {ybeName, expr, "' has lart) {yb;
  var hadCis.awaitPo.type CLASSs;
  IC_BLOCK |m.type =UPER  classBody.body = [];
  this.expect(types$1.braceL)}
  while (this.type !== types$1.braceR) {
    var stmt = this.par));
      }
   renR);
  node.body = this.parsey beenL expr, de(classBody, "ClassBody");
  th"& this.eat(m itatement ? "ClassDemma)) { break Statement` parameter).
| this.options.ecmaVersion if (node.lator));

  if (!LE_ID) && this.type !=ent` paramethodDefint scope (see
      // treatFuncckLValPattern(decl.idnsAsVae clas{s.type !=ent` parames.ecma.unexpeDefint scop(statement & FUNC_HANGING;

  ializati+ tatement ? "ClassDe&erOu{
 unctionExpression")if ( R) {
    vauent = this.parseStatx, ors)  );
  }
  node.lSubatempts= typesdecl.i? "loop" tatement parseClassSupepty.

var empty$1 ceL);
  while {ier '#" :$8.parseTopLevel = f,ouped:b;
}ict = true== "Privatt` ck !== null);
    ifurn this}
     ier '#"  tatement p= this.finispty.

var empty$1 ceL)reErrors);
e== "Privatt` ck !atement(rations '#"  ructu ier '#" ent(rati striructu  strNa"slassSnt ? "Cdent))esized== "PrUNCTIingErrors, isAss
 ! eenrrors);
e== "Privatt` ck   for (
Comma is noile eenrrif nt & FUNC_NULLABL== "Privatt` ck[eenr- 1
  vade.body.push(s to br str continue to.
  var i = ;

   strh - 1; i >= 0!hasOwn(ier '#" emedn if (s.eatContextgais noi("letent);
 is noi  str !== nid(element.kateNareIdment))  (refDestructuringErroidement)) {
d== "Pr{atemeas.raiseedn if (nt.keybel);
  ons '#"   reahis, "Ex!nodeelemen(element.key.name) + tateNC_HANGINkey && element.key.type === "PrivateIdentifier" ty$1 ceL).lastToRecoverable(elemnode);
  indtTo=== "PrivateId      vo
 // A  skip ="a.un"Na"slasst) {
      classBody.body.push(element)(;
      if (elemenis.v{.exp
      if (elemen& this.eatCon skip =        if (se {pe.iis.fii   inp
      if (");
  } else`xt();
{fvar #a(){};t else {sar #a(_){} }n onlylsoif (ey.ty
  // ExatCon indtTment.is.v{  i skip ment.ss.v{.eatCon indtTment.ss.v{  i skip ment.gs.v{.eatCon indtTmentsis.v{  i skip mentsss.v{.eatCon indtTmentsss.v{  i skip mentsis.v
nit.declar=== "PrivateId      p ="a.un"Na"selationalOperatisContextual(" indt.declar=== "PrivateId      p = skiNa"selationalOperatisContext{a"selational   if (!noteNC_HANGINfnR, KStart,pe();
  if (node.);
  ties ose wkennyrties os.options.ece wkenny   Na"s;
  var  ties osent)(a"selor = true;
   se if (element.this.lastT eleSTAT = funcor = true;
   LaultPament.thisame) {
  rtVhis. )notelse {
  sort' ant ? thickYieldAwait.return this.finthiAlt);
  // For beledStatement")
};
$8.parseSt    node.generator = this.eat(ty11n >= 9 || this.opSnode);
 ! eymaybhis.eatContearseExpr$8.e

  if (!LE_IDnly apfinthiart,p(element. scope (sepes$1._};
$8.p,earseExpr$8.e
[];
  nessBody = thx binding patterns reqarseExpr$8.e

  ialization valonsequent.ptemede);
 ! eyma`in`"nBody, isAsync= [];
  this.expe) { re   } else {
      if (this.if ( Rart, 
  if (!LE_IDde.lunction(decl, kion(node, expr) {
  node.expression = expr;
  ththiAlt);
  // Forr;
  return this.finorLabeledStatement")
};
$8.parseSt));
      }
   nt` wiorLa*/`in` '...'
 e.startNode();
    thi.ecmaVersion ement(node, maybeNamthiAlt);
  // For_import ? this.p(); }
    node.this.parseStas.type =   }nt` wiorLathis.rai...
ent. scope (sepes$1._};
$8.p,e"this.ra"[];
  nessBody = thx bindi");
    } else {
  if (!LE_IDde.$8.options);
  // For_);sion ement(node, pression = expr;
  ththioptions);
  // For".p(); }
nt` wiorLaion|t.typ|let|ledState|xt();
...
en)
};

pp$8houldPE_IDde.$8.ype !== ty)(node.lator))   } else {
  if (!LE_IDde.$8.op
  // For_impohis.type !== typkYieldAwait.e === types$1._in;
  this.nextthodDefint scope (ses$1._in;pes$1._};
$8.p,earseEkYieldAwait.   } else {
& FUNC_HAcmaVersiofint scope (sepes$1._};
$8.p,earseEkYieldAwait.FuncarseEkYieldAwait.Fu.labels FUNC_HANGINGegati(ele {yb;
  vas.if ( Rart, 
  ializati+tart = tnt` wiorLa{ x, yMENTzi+t[`in` '...']de.lator))   } else {
  ializationNGINGegati(ele {ybif (!LE_IDde.$8.Sgati(ele _};
$8.p = this.startNode()de);
 ! eyma`in`"nual("of"))) {
    if (th
  this.expe) { re   } else {
      if (this.vas.if ( Rart, 
  if (!LE_IDde.lunction(deding patterns reqde.body.push(stmt);
  }NGINGegati(ele ar i = 0, list = Object.kereIdment)) est(identde.b);

  //  striENTeats.strt,sIdment)) ceL)}gat  i < list.length; i += 1)(idenUne.  rv if}gat.eats.(element.) est(identif` wiorLaisExports[ength; i += 1)(idenLats.pes$1._}gat.eats.(elength; i maVergat.eats.= true;
   LaultPamrsion >= 9) {
 types$1._irgat.eats.=ment)) "A ) { retfaultPar
    { 
   striENTr Labe$8.e

")))) {
lowErt =``in``."(element.) At); }
   is.vas.if ( Rart, 
  ialization valuecl, kion(node, expr);
  if (createNewLexicalScope) { tfinthiart,d);
  // Forr;
  return this.finorL);
  // For beledStatement"pty$1 Accessole (this.type !== types$1
  return this.finorL);tions);
  // Forpty.

var empty$1 ceL)his.opti).
| this.options.ecmaVersionreturn thstructus$1. name("ecaserpreting it as .
  var i = fNons.ecmaVerorOf = this.opts$1._catch) {
    var c else) ? ti typeur) { thhis.options.ecmaVersion >= 6) {(fNons) {
  this.next();
ent & FUNC_STATE (declarationPositisContextual(is.options.ecmaVersionrxt();.handler = nuNons.ecmaVerorOf = this.opts$class:
    if (context)cNons) "pes$_in;ID"attern(init);
   rations '#lse {
  if (!LE_IDhht = isForIn ? t =cl, kion(node, expr)s$class:
ons '#lse {ati+ tatement e (sepes$1.   default va;
$8.p,eaelse turnnt")
};

p};
$8.parsrrors, isAssual(iVerofleSTAT if () { remm }
  if.lastTos/ ne true;
   se if (eleme?os/ ne.last:os/ nese.ke6isAssual(hasOwn(a;
$8.p,eaels.test(this.input.slucturingErroer;
 onstructor) wiorLa= mayn)
      ssignmena;
$8.p      p =e && !tatement e (sedecl.idpes$1.   default va;
$8.p,epa" ty$1 ceL) true;epa"e tru;Assual(iVere;
   se if (elemtest(this.inpe (sepes$1._};
$8.p,epa",epa".labels FUNC_ntextual(iVere;
   8.parsdecl.idmtest(thide.body.push(stmt);
  }pa".). Otherwiar i = 0, list = Object.keersiofinIdment)) ceL)). O  i < list.length; i += 1)(idendecl.idpes$1._};
$8.p,ep. O(element.kaUNC_ntextual(iVere;
   AhNoddecl.idmtest(thide.body.pution(node, mtion(pa".p
     r, context) {ion  for (var i$1 = == types$1._cert, "t) {io< list.lengt   var ceseExpressio(idendecl.idpes$1._};
$8.p,eeseEwaitAt); aUNC_ntextual(iVere;
     returtmtest(this.inpe (sedecl.idpes$1._};
$8.p,epa".se.kes FUNC_ntextual(iVere;
    isFor    decl.idmtest(this.inpe (sedecl.idpes$1._};
$8.p,epa".on ms FUNC_ntextual(iVere;
   RestElingComm }
  if (refe (sedecl.idpes$1._};
$8.p,epa".reak`/`cs FUNtatement e (ses$1._in;pes$1.   default va;
$8.p,eons rnnt")
};

p};
$8.parsrrors, isAssde.body.push(stmt);
  }ons rar i = 0, list = Object.keersio);
   rations   i < list.length (refe (sedecl.idpes$1._};
$8.p,e= this.   ifturn this.p8houldPE_IDde.$8.ype !== tpty.

var empty$1 Accessotion() {
rn this.indingAtom( = function() {
rn this.r);
    } els = function() {
rn this.r);
   elemes = function() {
rn this.r);
  ext)) &&
  = function(n this.  = function(n erpreting it asion >= 8);
  ressiomma-setion.e

ForInStart' ant ? this.return this.finthiSgati(ele   default va;
$8.p ty$1 ceL).ons.ecmaVerorOf = this.optaratioats.s  if (!LE_IDnly apfinthiart,p(el
tearseExpr$8.e

  if (!Snode);
 ! eymaybhi  );
  }
  nonly apfinthiart,p(t:osratioats.n(decl, ke (sepes$1._NC_HAc;
$8.p,ationNGINGxpr$8.e
[ationNGINGxpr$8.e
rorOf 
riabl
  if (createNewLexicalScope) { tfinthiSgati(eler;
  return this.finorLSgati(ele {ybdefault va;
$8.p ty$1 ceL).ons {yb;
 (dirsiname && !thnt` wiorLa{ x, yMENTzi+t[`in` '...']de.quent.ptemeuctor = false;
  classBody.s.finishNode(decl,ct(typen >= 9 || th!dirsiMethodDefi type true;
        cuVarielement.ual(is.op    {Tut.arseCuVarode(decl,ct(typen >oop")) { breaktart = tdirsinam.push(stmationNGINs (!cur) { this.ufinorLSgati(eleva;
$8.p expr);
  if (creNGINsion >= 8);
  redule'")kYieldAwait.return this.  retu "FunctionExpression")
};

.parseClass = dule'")'...'
 e.startNod) {
  return this) { re(node.lator))egati(ele {yb added   vas.if ( Rart, 
  if (!LE_IDde.lunction(dern(init);
   NGINGegati(ele {ybif (!LE_ID  retuSgati(ele _e(0);
    }
  temede);
 ! eyma`in`"nBodys.if ( Rart, 
  if (!) {
  return this) { ret );
  }
  node.lunctioC_NULLABon >= 6 && this.+ "' has aon(node, exptypes$1._else) ? this.parseStatemmnorL);
  // For"sion >= 8);
  ressiomma-setion.e

ForInStart' antdule'"s.return this.  retuSgati(ele   default v ty$1 ceL).ons.ecmaVerorOf = this.optaratidule'"e

  if (!LE_IDnly apfinthiart,p(el
 || this.opSnode);
 ! eymaybhis.eatConaratioats.s  if (!LE_IDse if(ybode();
    this.finis(idenUne.  rv ifaratidule'"e
nBodys.if ( oats.s  aratidule'"e
his.+ "' has e (see
      // treatoats.,heckLValPattern(ptypes$1._else) ? this.parseStatemmnorLSgati(eler;
  return this.mmnorL);tionsSgati(ele   default v ty$1  = dule'")this.ra8.p,a{ x, yMENTzi+t`in` '...'
 eceL).ons.ecmaVerorOf = this.optaratioats.s  if (!LE_IDse if(ybode has e (see
      // treatoats.,heckLValPattern(types$1._else) ? this.parseStatemmnorL);tionsSgati(eler;
  return this.mmnorLart,se.laSgati(ele   default v ty$1 ceL).ons.ecmaVerorOf = this.opt));
      }
   renR);
temede);
 ! eymaybhi.optaratioats.s  if (!LE_IDse if(ybode has e (see
      // treatoats.,heckLValPattern(types$1._else) ? this.parseStatemmnorLart,se.laSgati(eler;
  return this.mmnorLSgati(ele {ybdefault v ty$1 ceL).ons {yb;
 (dirsiname && !th| this.options.ecmaVersion if (node.lator)s (!cur) { this.ummnorL);tionsSgati(ele(ons.push(this.finishNode(decl, "Variableif (creNGINsr = true;
   if (!) {
  return this) ClassElivator)s (!cur) { this.ummnorLart,se.laSgati(ele(ons.pushif (creNGINsialonsequent.ptemeuctor = false;
  classBody.s.finishNode(decl,ct(typen >= 9 || th!dirsiMethodDefi type true;
        cuVarielement.ual(is.op    {Tut.arseCuVarode(decl,ct(typen >oop")) { breaktart = tdirsinam.push(stmationNGINs (!cur) { this.ummnorLSgati(ele( expr);
  if (creNGINsion >turn this.nly apfinthiart,{ybdefault v ty$1     node.generator = this.eat(ty13ENT) {
    nod return this) { re(node.laceL)}
rect(tultPar  if (!LE_ID(tultPahis.opame) ns.push(thide,eSurrogn.et = fu}
rect(tultPapame) nMethodDefi types$1._i}
rect(tultPapment)) "A Labe$8.yn)
  
    { includ ? "F teasurrogn.etex bindinbindiif (cre}
rect(tultPa
r);
  if (createNeLE_IDse if(a.unexon >= 8Set ` this.semicolon();
#dlowSuive`t>= 0)
   de.bdlowSuivet>= loguNs >turn adaptDlowSuiveP= loguN{ybdefault vement")
};Statement = funcsh(s to brement")
};witch ?  === typesDlowSuiveCandixprevement")
};ist)ue to.
  var ement")
};ist.dlowSuivet= ement")
};ist. will alrearawe) {
  1,(ref  ifturn at(tyasDlowSuiveCandixpre{ybdefault vement")
}pty$1 Accessorthis.finisgenerator = this.eat(ty5claratioement")
}e true;
    this.semicolon();
 claratioement")
}e will alrea true;
   LaultPamentthis.fVeroflement")
}e will alreaame) {
  rn) { rementthis.ependdeclap
// part ze

) { res.
ent.unction(nod[ement")
}ement)]{
  rn\""bility to inod[ement")
}ement)]{
  rn'mm }
), kind ==at(7{yb);
  r..type ===n >= 8de)vlookpartu retxpressionStanctarataof loop m
      tolon fuments,l, which7for-of loop ma)) { break Statemen.expect with 'let'."); }
    thity$1     node.generator = this.eat(tyns.ecpression")ioehis.ty treat ===sion")io type se if (elem:lement.ual(is.opin{
sGode.gtreat.lastT elersion >lengt   v null;
  if (!node.handlerC    { ;
  'rsion'MENT`       thiinunctismentsGod
    { this.raisssssop"))
n")io type 8.parsdecl.idm:n")io type AhNoddecl.idm:n")io type AisFor    decl.idm:n")io type RestElingCom:aisssssop"))
n")io type 8.parsode(node, i:aissssstreat ===    8.parsdecl.idmelement.ual(ith 'let'."); }
    thityh (refe (sedecl.idpIn(node, init)
  } else {
    this.c.raisssssde.body.push(stmt);
  }NGING). Otherwiar i = 0, list = Object.keinIdment)) ceL)). O  i < list.length;  {
   r-of loop ma). Oemen.expect(element.) estEa thee {
 :lement.) est  AisFor    Rest  returt[Yteme
 , thi] :lement.) est    `...`isForOf = falsAisFor    Target[Yteme
 , thi]lement.) eslement.) est  I(statemS= thx e {
 e.st|sForOf = falsAisFor    Target|yaeak  |AhNodLaultPa|
 );k  |8.parsLaultPa|.lement.) / ExatConnnnnnn). O  true;
   RestElingComentthis.......a). O.reak`/`c  true;
   AhNoddecl.idmbili). O.reak`/`c  true;
   8.parsdecl.idmtest(tttttrsion >= 9) {
 types$1._i). O.reak`/`c .handlerUn >= 6 &&n t ma"(element.) At); }
   isssssop"))
n")io type   returtm:lement.is.nisFor    d= 0)
   .staiVere;
     returtmlement.ual(NGINGnst | if (ush(  { break }
    }
  } element)) "8.pars
      tvare'n" 'gaain is.  {  );ss.  {his.raisssss {
   r-of loop ma}
  }ame) emen.expect(element.op"))
n")io type AhNodode(node, i:aissssstreat ===    AhNoddecl.idmelement.ual(ith 'let'."); }
    thityh (refe (sedecl.idpIn(node, init)
  } else {
    this.c.raisssss {
   r-of loop m(typeNGINGxlt")
};

en.expect(element.op"))
n")io type Sp, ("ElingCom:aissssstreat ===    RestElingCom;aisssss {
   r-of loop ma}
  }reak`/`c

en.expect(element.ual(NGINGreak`/`c  true;
   AisFor    decl.idmtest(ttttt break }
    }
  }reak`/`c .handlerRestnp
     s 
    {  : "frtthis.raiComplex    isssssop"))
n")io type AisFor    ode(node, i:aisssssual(NGINGretutypes if (=  { break }
    }
  }on m.eontexO Rem'=' retutypes
   
   stride.begati(y retthis.raiCompl." (this.vas.if (  ===    AisFor    decl.idmelement.dp
 te NGINGretutype;aisssss {
   r-of loop ma}
  }on m

en.expect(element.op"))
n")io type P
// part ze
ode(node, i:aisssss {
   r-of loop ma}
  }xpressionSemen.expect with 'let'."); }
    thielement.op"))
n")io type Chainode(node, i:aisssss {
  ut.slucturingErro!node.handlerO (and `bchain!node.   { appefDesttsWithLet && is"ielement.op"))
n")io type Memberode(node, i:aisssssual(!en.expect( >oop")) { 
ent.dpis.ra:aisssss {
  ut.slo!node.handler-of lo!nodratrComplex bindin
isContextual(ith 'let'."); }
    thityh (refe (sedecl.idpIn(node, init)
  } else {
    this.c.rais
    if (!this.e= 8de)vlookForInStaxpressionStancthe n
")))) {
 0, lwhich7for-of loop mL);
  }default va;
rL);


en.expect(ty$1 ceL);t || a;
rL);
   for (
Coent = funcsh(s to br;t  to++es$1.braceL);
t|| a;
rL);
h - 1; i >= 0eseExpressio r-of loop maese

en.expect(er = true;
   endes$1.braceL)' wen| a;
rL);
h;t |- 1
  va1     node.generator = this.eat;
  6ent.ke.expectent.' wennt.' we  true;
   RestElingComent.' we reak`/`c  true else if (!allowexpeDefint scop(statement ' we reak`/`c labels FUNC_rais
    ifa;
rL);
ion >= 8);
  resp, ("np
      which7fhis.typ, ("n }default vith 'let'."); }
    thity$1 ceL).ons.ecmaVerorOf = this.opt));
      }
   }
  }reak`/`c
  if (!LE_IDhht = isForIstart with 'let'."); }
    this.toclassBody, "ClassBody");
  th"&p, ("ElingCom;
  retur7eturn thst.expecte  default v ty$1 ceL).ons.ecmaVerorOf = this.opt));
      }
 
s.ependstElingCoiinunctiStaING_STATEMEtion or lybel);
  thisif (!allo$1     node.generator = this.eat;
  6ent.    if (th
  this.expenr label = } else {
      if (thi   }
  }reak`/`c
  if (!LE_IDrId = function(.toclassBody, "ClassBody");
  th"RestElingComm on >= 8);
  relame) {(aof loop m)tanct which7fhis.trId = funct{ybdefault v ty$1     node.generator = this.eat(ty6sion")ioehis.ty     if (tsion")io typeurn this.typketL:aisssssceL).ons.ecmaVerorOf = this.optssss {
  tartNode());
 NGINGxlt")
};
  if (!LE_IDrId = f(types$1.pare.typketR  this  this.ce());
 classBody, "ClassBody");
  th"AhNoddecl.idmten")io typeurn this.typeL:aisssssif (createNeLE_ID8.p(a.unexpeDeUNC_rais
    ifif (!LE_IDse if(y
  retur7eturn rId = f(typ{ybdefault v "ExpFunctionaddeFunctioTut.arseCuVarations.
in 
eymhity$1 ceL)ese {yb;
 (dirsiname && !thssBody.s.finishNo "Expen >= 9 || thdirsiMettdirsinam.push(stm 9 |art = t type true;
        cuVarieFUNC_HAat inctionaddeENT) {
    nod return thiscuVarision >= 9ese  (!curpes$1.braceContextual(nctioTut.arseCuVarENT) {
      {Tut.arseCuVaro "Expen >= 9 |t.op"))
raceContextual( {
    nod return thisellipsisn >= 9 |t.ceL)reatement = functthst.expectis.optssss {
  turn rId = f(typItem(reats.optssssese  (!curreats.optssssual( {
    nod return thiscuVarisis {
  ut.slucturingErromaVerorOf textuaarE  // t`/`omit &&n    { th  s.traelingCommc.raisssss {
   true;
 "Expe;= 9 |t.op"))
raceContextion >= 9ese  (!cur {
  turn -of loop mL);
Item(ions.
in 
eymhix bindin
isCais
    ifase 
  retur7eturn -of loop mL);
Item{ybdefault vions.
in 
eymhity$1 ceL)esem
  if (!LE_IDhht =);tionsomaVerorOf temaVerorOf is.starA {
  turn rId = f(typItem(esem   ifurn this}
 
  retur7eturn rId = f(typItem{ybdefault vtion pty$1 AccessopEXICAL);
= 8);
  resisFor    
      tvarout |giveStancta fuments,l, which7fLE_IDhht =);tions{ybdefault vemerldYielorOf is.,tsWitpty$1 on may on maility torseVarId = function(de= this.parseCatchClauseParam();6    }.finishNode(decl,s.pars Accessoon masAss
 ! .ons.ecmaVerorOf = thAtvemerldYielorOf is.i.optaration may on m.optaratinitializif (!LE_IDhht = isForIis.toclassBody, "ClassBody");
  th"AisFor    decl.idmteL);
= 8dssSfoons.!nodrhreebdefault nlyll rini(y ")
};
 .ons.aeak  lame) {— a `foon e!nodrh
};
   
  bout }
 );sisFor&&n t. ItInDd { to do`foect ty`/`ostat a `aatemeet= keye (ses: a  a `-oCidentrh
};n teae, the bout /sisFor&&-to sif (!allos;

//e.  rv i 
  //. a `-ouctureas/ nsed block of sFUNCbId = frneRecoveappropripre{sreat. a `-oCidentdstructor)reak`/`c
trt,s,e= te (sentexh reds;ss.. a  a `Ifessioml("of")))) {
      teds;encout    i (e.g.}
 .pars
et &shNod a `d'let'."); }
)ect tof (!re
      teds;recuParveRemo (seed. a  a `dssse(tredrhreebveParams keye (see
  *v tappropripre{de.bdlffe// p a `circumorOnces: a  a `-oe (see
      // ) shyll 
   strii, the s= thcse {t.type == suple'"s
est  / te!nodo // trh
n sif (!allos;
t &memberaxpressionSs. P
// part ze

est  xpressionSs;

// Psoif rowSuly
// Paed.`dsireds;;
  th    appropripre{de.
est  t.type == sFUNCt")
};the sgat says a  a `  > I(statemS= thx e {
 e.stAisFor    TargetT nodkey[the produault ]E  // t a `  > _SIMPL. a  a `  I(statePsoiappropripre{de.be (se!nod.st
n sif (!allostatameid;
t &/ t a `  xports[ontexwsssetmt)keedule'")kYieldAwaitsalizeefault /xt();
sif (!allos. a  a `  ExaIMPL statrfor)arti/  striinclud :
est    aect.…;
est    dule'")at`in` '…';
est  tatrforE  /the .ons. n
"emo (seed. a  a `-oe (see
  decl.id ) shyll 
   strii, the s= thcse {t.type == suple'"s
est  anyte!node (see
      // ) suple'"sEMENTwe. Ths
 .pars
et &shNod a ` `d'let'."); }

      th.`dsireds;;
  th    appropripre{de. t.type == sFUN
est  ta)
};the sgat says a  a `  > I(statemS= thx e {
 e.st[the produault ]E  //ei // t
n 8.parsLaultPa .or a `  > 
n AhNodLaultPa
et &AisFor    TargetT nodkey[the produault ]E  // t a `  > _SIMPL. a  a `  ExaIMPL statrfor)arti/  striinclud :
est    (a t.…);
est    t.typ a t.…;
est    tryrs …eCoe.fina(risis…eC
est  tatrforE  /the .ons. n
"emo (seed. a  a `-oe (see
  In  tdecl.id ) shyll 
   strii, the s= thcse {t.type == suple'"s
est  anyte!node (see
  decl.id ) suple'"sEMENTwe. Ths
this.raisisFor    
est        th, s.traelingCosEMEt &o // tt.type == srh
};"forappefDelowE reah
est   .pars
 );shNod`d'let'."); }

      t. a  a `  AatemegatiPar
 is.pa_STATEMEtion or latePsoi;
  e (see
  In  tdecl.id ),
est  asct ty`ePsoisuple'"
this.ras;
t &s.trat.type == . a  a `dsssebdefault nldelibtutyeRemsuple'"
bo /esisFor    

t &")))) {
t.type == ,
estasct t loge {aUNCbo /eds;excee)) {Remsimield.`Ifethe .ons.  /the targetdke
estanesisFor    it is a")))) {T nodshould"
  sar  n
eckLVNONE    // subjecie a `fhould"
  sar  n
coveappropripre{eckLV*
t.typa  itt)keeerator ||or a `eckLValPatte. a  a `IfecoveNC_HANGINkemove `allowEx
 .on-eckLVNONEa")))) {T noit is 
estaddi(and `   ate (sentexh re .pars
"forbe egati(eldarataons.be (se!nodFUN
estdstructor)reak`/`c
trt,s.te (sentexh reds;Forortrii, the provsifd
t.type ==olon stanesisFor     (i.e.}
")))) {T nod steckLVNONE) which7fe (see
      //  }default va;
r,a")))) {T noite (sentexh r ty$1     
")))) {T nodvoid 0 ) crea")))) {T nodvteckLVNONEvo
 // A ke.expdvt")))) {T nod
  teckLVNONEvo
 /ehis.ty a;
rif (tsion") type se if (elem:lemen)
};

pp$8lreadyNT) {
  e.  rv iW  // decla.expt = fua;
riaels.test(t(this.input.slucturingErroa;
riment)) {ke.expd? ".expecteis.fi-of lo!nodrat   inp;
riaels initinClass DefiniaybFUNC_HAat i eBindes$1.braHAat i")))) {T nodvoidode.async) ?     ;
riaels ;
   len >lengt   v null;
  if ucturingErroa;
riment))  lenaisExisaons.triENTr on.stri   bout 
trt,mmc.raisssss| thfnR, ntexh r ty$1 isssss| thhasOwn(fnR, ntexh r, a;
riaels.test(t(t   v null;
  if ucturingErroa;
riment))  Aeak`/`c
trt,deelehent.start, "DufnR, ntexh r[a;
riaels]name && !thindin
israHAat i")))) {T nod
  teckLVOUTSIDEisis {
  ons '#"art,pu;
riaels,a")))) {T noita;
riment)EwaitAt); 
 |t.op"))

io type Chainode(node, i:aisssull;
  if ucturingErroa;
riment))  O (and `bchain!node.   { appefDesttsWithLet && is"ielemenop"))

io type Memberode(node, i:aisssat i eBindes$sull;
  if ucturingErroa;
riment))  .expectememberaxpressionSent.start,op"))

io type P
// part ze
ode(node, i:aisssat i eBindes$sull;
  if ucturingErroa;
riment))  .expectep
// part ze

xpressionSent.start,classBody, "e (see
      // a;
rixpressionSem")))) {T noite (sentexh r 

iodpis.ra:aisss {
  ut.sloa;
riment)) {ke.expd? ".expectis.fi-of lo!nodra   initrComplex bin}
  retur7ee (see
  decl.id  }default va;
r,a")))) {T noite (sentexh r ty$1     
")))) {T nodvoid 0 ) crea")))) {T nodvteckLVNONEvo
 /ehis.ty a;
rif (tsion") type 8.parsdecl.idm:n")iode.body.push(stmt);
  }a;
ri). Otherwiar i = 0, list = Object.keinIdment)ceL)). O  i < list.lengthdy, "e (see
  In  tdecl.id ). Oem")))) {T noite (sentexh r ;tAt); 
 |t.op"))

io type AhNoddecl.idm:n")iode.body.pution(node, mtion(a;
rix
     r, context) {ion  for (var i$1 = == types$1._cerem{ybt) {io< list.lengtlasst) {ityh (refe (see
  In  tdecl.id t) {em")))) {T noite (sentexh r ;aitAt); 
 |t.op"))

iodpis.ra:aisss {
  e (see
      // a;
rem")))) {T noite (sentexh r ;tAt}
  retur7ee (see
  In  tdecl.id  }default va;
r,a")))) {T noite (sentexh r ty$1     
")))) {T nodvoid 0 ) crea")))) {T nodvteckLVNONEvo
 /ehis.ty a;
rif (tsion") type   returtm:lemenis.nisFor    d= 0)
   .staiVere;
     returtmlemen (refe (see
  In  tdecl.id t;
riame) em")))) {T noite (sentexh r ;tAt);op"))

io type AisFor    decl.idm:n")io (refe (see
  decl.id t;
rion m

")))) {T noite (sentexh r ;tAt);op"))

io type RestElingCom:aisss (refe (see
  decl.id t;
rireak`/`c

")))) {T noite (sentexh r ;tAt);op"))

iodpis.ra:aisss {
  e (see
  decl.id t;
rem")))) {T noite (sentexh r ;tAt}
  re= 8dssSalgorowEm  strito dor lmine tat // t
mentt;
;
   appefDe
};
e= 8giveStpoiCoiin the progon aisElooseRembastriGINsweet.js'eapproach.>= 8See https://gowEubscuV/mozilla/sweet.js/wiki/d'lFor
ind ==Tokde);
 !  }default =Tokde);
 !( t ma

enE;
rempe.  rv Se.la, urinri  thgator = tru }
 essio rkenrrorrkentarA {
  enE;
r f (thiE;
rtarA {
  te.  rv Se.la f (tte.  rv Se.latarA {
  urinri   f urinri  tarA {
  _STATEMENT))!!_STATEMENd, kind ==de(deT)) }
 b_emen: new=Tokde);
 !("{"esdecl.i,}
 b_t;
r: new=Tokde);
 !("{"esa.une,}
 b_t  /: new=Tokde);
 !("${"esdecl.i,}
 p_emen: new=Tokde);
 !("("esdecl.i,}
 p_t;
r: new=Tokde);
 !("("esa.une,}
 q_t  /: new=Tokde);
 !("`"  this  this.pa_STATEME(pars Accessop.tryReadTe  /torTrkenf (the,}
 f_emen: new=Tokde);
 !("
    { thesdecl.i,}
 f_t;
r: new=Tokde);
 !("
    { thesa.une,}
 f_t;
r__ST: new=Tokde);
 !("
    { thesa.un (declara typesa.une,}
 f__ST: new=Tokde);
 !("
    { thes this.paeclara typesa.une, kind ==at(6{yb);
  r..type ===n >at(6.of") + de);
 !  }default mpty$1 Accesso[de(de.b_emen]
  retur6Nainde);
 !  }default mpty$1 Accesso {
  ee);
 ![ {
  ee);
 !witch ? - 1

  retur6N.typeIs.eat( "FunctionExte.vT (tsion")mma is noile  {
  einde);
 !ion(de= this noilereturn t.f_t;
rbili)s noilereturn t.f_emenabel = }ational   itrue;
   te.vT (td return thisculEMEnt)()s noilereturn t.b_emenbili)s noilereturn t.b_t;
r)abel = }ational!is noi enE;
r   } elsedssS(identde.b`ttiaels     ;
rAons.tr` dor == stat // twe(tre} else    { a `ode, `
 );`of`
t.type ==.8See the `upxprede);
 !& FUN} else`ttiaels`.ue;
   te.vT (td return this_ationalili)..vT (td return thisaels     {
   trrAons.trabel = }ationallineBp"))t = futy to inode) {
  ty toessBodyEndtemaVerorOf ))true;
   te.vT (td return this_ntextili)..vT (td return thisaon(tili)..vT (td return thisroflili)..vT (td return thisnL);
 lili)..vT (td return thisarrowabel = }ational   itrue;
   te.vT (td return thisalse;
 bel = }ational)s noilereturn t.b_emenbrue;
   te.vT (td return this_mma ili)..vT (td return this_t.typ ili)..vT (td return thisaels bel = }ationalaeclasCais
    if! {
   trrAons.tr
  retur6Nin.eat(typede);
 !  }default mpty$1 de.body.push( {
  ee);
 !witch ? - 1Obje(ty1Obj--.handler = nue);
 !  } {
  ee);
 ![ - 1; i >= 0ee);
 !w rkenrr;
  ext)) &&
test(t(thi
    ifee);
 !w_STATEMENTn
isCais
    ifOperat  retur6Nupxprede);
 ! "FunctionExte.vT (tsion")mma upxpre,) true;e {
    non(de= thi {
rn this.r   )..vT (td return thisdotabel = } else trrAons.trnam.push(stm 9ntextual(upxpre eturn Nupxprede);
 !abel = }upxpre.tri  ty t, )..vT (ts FUNC_ntexbel = } else trrAons.trnamurn Nbede.ode.l;t}
  re= 8Ustrito // Pae edgeo typ statnn t mayue);
 ! could"  { 
  infinrfd
t.rowSuly
d); }

 t maizlse {
p.steretur6Nurinri  de);
 ! "FunctionEx t maCtx ty$1     node.einde);
 !ioh
  tht maCtx ty$1  o {
  ee);
 ![ {
  ee);
 !witch ? - 1
  tht maCtx;tAt}
  re= 8dt ma-egati(ecyue);
 ! upxpre ions

urn thisnL);
 Nupxprede);
 ! "Fde(decl,ct(typNupxprede);
 ! "FunctionEx ty$1     node.ee);
 !witch ? ==1 = == type else trrAons.trnamu && !thin
    i
isCais/ A cu!  } {
  ee);
 ! !atement(    cu!  return t.b_emenb    {
  einde);
 !iow rkenrr;
  ext)) &&
t== typecu!  } {
  ee);
 ! !atement(onsequent.ptrAons.trnam!cu!.hiE;
rta  reurn thisalse;
Nupxprede);
 ! "FunctionExte.vT (tsion") {
  ee);
 ! !!cur {
  .typeIs.eat(xte.vT (tsi?turn t.b_emenb:turn t.b_t;
r);nsequent.ptrAons.trname && !tateurn thisdollarBlse;
Nupxprede);
 ! "FunctionExsion") {
  ee);
 ! !!cur rn t.b_t  /);nsequent.ptrAons.trname && !tateurn thisr 1ibcNupxprede);
 ! "FunctionExte.vT (tsion")mma ement")
}P
// eT)))..vT (td return this_iflili)..vT (td return this_foa ili)..vT (td return this_lowExili)..vT (td return this_lsBod;n") {
  ee);
 ! !!curement")
}P
// eT?turn t.p_emenb:turn t.p_t;
r);nsequent.ptrAons.trname && !tateurn thisincDecNupxprede);
 ! "FunctionExsion")= 8 rkEptrAons.trnemeys nct// gtr
  reurn this_fnctionENupxprede);
 ! "Fde(decl,rxt();Nupxprede);
 ! "FunctionExte.vT (tsion")
   te.vT (tNbede.ode.lr   )..vT (td!return this_ntextntthis...! te.vT (td return thisaon(t    {
  einde);
 !iod!return t.p_emen)tntthis...! te.vT (td return this_ationalnt.'ineBp"))t = futy to inode) {
  ty toessBodyEndtemaVerorOf )))tntthis...!  te.vT (td return thisculEMEili)..vT (td return thisalse;
 t    {
  einde);
 !iod return t.b_emen.test(this.inpee);
 ! !!cur rn t.f_t;
r);FUNC_ntexbel = } elseee);
 ! !!cur rn t.f_emen.;(onsequent.ptrAons.trnamitkl-ca  reurn thisculEMNupxprede);
 ! "FunctionEx ty$1     node.einde);
 !iow rkenrr;
  ext)) &&
t==} {
  ee);
 ! !ateme(onsequent.ptrAons.trname && !tateurn thisbackQuoteNupxprede);
 ! "FunctionEx ty$1     node.einde);
 !iod return t.q_t  /test(this.inpee);
 ! !ateme(onsentexbel = } elseee);
 ! !!cur rn t.q_t  /t;(onsequent.ptrAons.trnamitkl-ca  reurn thisorOfNupxprede);
 ! "FunctionExte.vT (tsion")
   te.vT (ts.ecmaVersionreturn th.
  var i = ;ndexsh( {
  ee);
 !witch ? - 1O1; i >= 0 {
  ee);
 ![ ndex]lereturn t.f_t;
rthodDefint scopee);
 ![ ndex]leturn t.f_t;
r__ST FUNC_HAcmaVersiofint scopee);
 ![ ndex]leturn t.f__ST FUNC_onsequent.ptrAons.trname && !tateurn thiss/ neupxprede);
 ! "FunctionExte.vT (tsion")mma aons.trnamitkl-ca1     node.generator = this.eat(tyns.ec)..vT (td!return thisdota >= 9 || this.opame) {
  rnof"ssElivateN.ptrAons.trn = functype elseame) {
  rnode, "  === typen.eat(typede);
 !(.test(t(thiaons.trname && FUNC_onsequent.ptrAons.trnamaons.tr;
  re= 8A;recuParve`d'lc   
  
  r retutyp sby xport!nodFefault nlfoa aon a `f= thcse {elingCosEMEt &recuParveRemoaon!nodrhExpFueachdFefault 
estadvanc!nodrh  innodClaseamMEt &reiona!nod
n ASTtarati Precedence
estkeye.type == s(foa exaIMPLect tofhcssrh
};`!x[1]` mea nl`!(x[1])`olon typ ("nkey`(!x)[1]` is
// Paedsby t tofhcssrh
};the p 
  rolona_STATEMErh
};p;
  reunaryc)..fix retutypesNkemove `aldirsiEMEt olon t    ifeve secoveNC_HANGINrh
};p;
  re`[]` subatempts{—Nrh
}olonwayecie'll&receiveethe .ons.de.b`x[1]` al, ("y;p;
  dEMEt &wraps
est*rh
}*iin the unarycretutypesarati a  a `At.rn  ststane[retutypesprecedence p 
  r][rep]ito // Pae binary
estketutypesprecedence, 
 ca;
  inaisEmuchdme.ony arlcssrh
n  s!no
estthe techniq) {cu!lrts[oaburi, ta)
}; ststdlffe// p, netu reolona_STATEMhe n
egati(ysprecedence, foa aonae, the ts a"))ary
estprecedence level srh
};JavaStempt xports . a  a `[rep]: http://en.wikipedia.org/wiki/Oetutype-precedence_p 
  roind ==at(5{yb);
  r..type ===n >= 8didentif`>= 0)
   s/ ndeelehp stowEx
l, ("y;added. a  8.pars/xt();
is.  {s;
t &ss.  {s;
nt)) {
}ons.trn n
eeleh{— a `ei // ttowExeachdo // to ttowEx
n sn in>= 0)
   —N
t &i 
estlass Defini, sn in>= 0)
 ies;

// Psoi) {
}ons.trn n
b//e.ppLevd which5)esized=opntexh "FunctionExte Oemte OHexh with 'let'."); }
    thity$1     node.generator = this.eat(ty9s.ec). O  true;
   &p, ("ElingCom;
(t(thi
    if}a1     node.generator = this.eat(tyns.eci). O. ties oseili). O.on ete ili). O.shorrh
nd)abel = }ationalCais/ A .ece w). O.   Na"sceL).las;
 /ehis.ty or = trusion") type se if (elem:f.lastToble(elemn.op"))
ra type LaultPam:f.lastToS { re(thisame) )n.op"))
radpis.ra:n
    i
isCais/ A nst || ). O. f (");
    node.generator = this.eat(ty6sion")ioual(Nels ;
   __.type__"s  iu
   =if (ush(  { est(t(t
   te OHexh..type ty$1 isssss| thith 'let'."); }
    thity$1 1 isssss| thith 'let'."); }
    thsdoubleP=  n
< 0ity$1 1 isssss with 'let'."); }
    thsdoubleP=  n
Toble(orOf ;$1 1 isssssstart, "DukateNareIdment)) ssull;
  if ucturingErro element)) "Red.push(eleae, __.type__n>= 0)
  "(element.) At); }
   issssste OHexh..typenamu && !thinstart,classB
isCais.lastTo"$ mayn)
 Na"sceL)o // t=ste OHexh      vot(    c // .
  var i = red.push(eleO1; i >= 0u
   =if (ush(  { est(t(tred.push(ele.ecmaVerorreadyNT)c // .of") ilic // .getdilic // .ss..braceContext est(t(tred.push(ele.ecc // .of") ilic // [u
  ] !thinstart,| thitd.push(eletest(t(this.input.slucturingErro element)) "Red.push(eleae, >= 0)
  "(ensAsVae clas{s.typo // t=ste OHexh      T)) }
 art,|sh(:paeclar}
 art,get:paeclar}
 art,set:paecla!thinsent(onsec // [u
  ]name && !tateest### ode(node,  p 
  reo a `dsssebnetu,t`in` the most;;
  th axpressionSt true
};the top to a `'anctic'ncarndivits,l,axpressionSt truse
};the botnct  Mostdke
estcoveNC_HANGI stoona_SIMPy lenacoveNC_HANGI(hitbens.bcovm p 
  ,
estandte*if* the s= thcse {t.type == t ty`// Pae isEte.   p, wrap
estcoveASTtaratsrh
};the in  t
  
  r gaveethem  reaho // tarati 
= 8);
  aING_l axpressionS.edssSo (and `break`/`co;

// stritoolonaorbid the `in`tketutypes( refoa loops,|sh(+ " lse {
xpressionSs)
estand provsifwithe// cs.de.bsype!nod'=' retutypesinunctishorrh
nd
estpr 0)
   sisFor     iayue);
 ! statrfobo /e .pars
xpressionS
estand o.pars
      tvmitialappefDe(soiie'suments,l,dratrt.sl a `d'laytrne= thx e {
 e
};t.rowSuumenh(elet which5)
  node.lssionSt  default vaorIn i with 'let'."); }
    thity$1 mma emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.Na"sceL)e;
r f if (!LE_IDhht = isForIaorIn i with 'let'."); }
    thi");
    node.t (td return thiscuVarision >=
 ! .ons.ecmaVerorOf = thAtvemerldYielorOf is.i.optonNGINGxpressionSs;= [a;
r] !thinssBody.body shNode(decl, "VariableNGINGxpressionSs (!cur {
  turn hht = isForIaorIn i with 'let'."); }
    thint.start,classBody, "ClassBody");
  th"&eq)  csode(node, i.p(); }

    ifa;
rAL);
= 8);
  tanesisFor     xpressionS.edsds;Fnclud slappructorams ke
estketutypestt)kee`+=` which5)
  nohht = isFort  default vaorIn i with 'let'."); }
    th,e    {Left);
  ity$1     node.isde);
 ! eymaode, ")a >= 9 || this.open.eat(typears Accesso {
  turn YtemevaorIn i).start,lsedssS t maiz/ tto. Thssk`/Tr LabelssionSttatePns.triE   {tart,lse`ode, `, 
utor)arti/e'n"rh
};u
   e, ode, NC_HAcmaV= } else trrAons.trnam.push(stm 9}o
 // A cwn 'let'."); }
    thnam.push,beenP
//  isFort  -1,beenTut.arseCuVarE  -1,beenDoubleP=  n
To-1");
    ith 'let'."); }
    thity$1 1 eenP
//  isFort  ith 'let'."); }
    thsp
// part ze
 isFor;$1 1 eenTut.arseCuVarE  ith 'let'."); }
    thstut.arseCuVar;$1 1 eenDoubleP=  n
Toith 'let'."); }
    thsdoubleP=  n !thin
 h 'let'."); }
    thsp
// part ze
 isForE  ith 'let'."); }
    thstut.arseCuVar
To-1");
Context{a"selath 'let'."); }
    th = new= 'let'."); }
    th;$1 1 ewn 'let'."); }
    thnamu && !th}o
 // A emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.Na"s    node.t (td return thisr 1ibcaility tot (td return this if (node.la {
  tot if alArrowAt.ecmaVerorOf ;de.la {
  tot if alArrowInFor, thinam.orIn itT elersion ent(onse
 ! eefalizif (!LE_IDhht =Crndi(and `IaorIn i with 'let'."); }
    thi");
        {Left);
  ity eefaliz    {Left);
  .tri  ty t, on m

emerldYielorOf is.i.true;
   if (!) {
(n ersForision >=
 ! .ons.ecmaVerorOf = thAtvemerldYielorOf is.i.optonNGINGretutypes=e elseame) O1; i >= 0 {
  t (td return thiseqtest(t(thieefalizif (! r-of loop maon m

start with 'let'."); }
    thisnstart,| th!ewn 'let'."); }
    th { est(t(treh 'let'."); }
    thsp
// part ze
 isForE  ith 'let'."); }
    thstut.arseCuVar
Toith 'let'."); }
    thsdoubleP=  n
To-1 !thinstart,| thith 'let'."); }
    thsshorrh
nd isForE>y on mrorOf )est(t(thiith 'let'."); }
    thsshorrh
nd isForETo-1 
Colsee.  t 
 ca;
  shorrh
nd
this.raiwa/  strit.rowSuly1; i >= 0 {
  t (td return thiseqtest(t(thi {
  e (see
  decl.id on ms FUNC_HAcmaVersiofint scope (see
      // on ms FUNC_HAaration may on m.optss {
  tartNode());aratinitializif (!LE_IDhht = isForIaorIn i)O1; i >= 0eenDoubleP=  n
>(refthiith 'let'."); }
    thsdoubleP=  n
ToeenDoubleP=  nt.start,classBody, "ClassBody");
  th"AisFor    ode(node, iattern(init);
   >= 0ewn 'let'."); }
    th { t scope (seode(node, pIn(node, init)
  } else {
    this.c.raisrue;
   eenP
//  isFort>(refthiith 'let'."); }
    thsp
// part ze
 isForE  eenP
//  isFor;srue;
   eenTut.arseCuVarE>(refthiith 'let'."); }
    thstut.arseCuVar
ToeenTut.arseCuVarc.rais
    ifon mAL);
= 8);
  ta l.idaryccrndi(and ` (`?:`)tketutype which5)
  nohht =Crndi(and `t  default vaorIn i with 'let'."); }
    thity$1 mma emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.Na"sceL)e;
r f if (!LE_IDode(OpsIaorIn i with 'let'."); }
    thi");
    node.e (seode(node, pIn(node, init)
  } else {
  pars Accessoe;
r   }
    node.this.parseStq) s(eletision >=
 ! .ons.ecmaVerorOf = thAtvemerldYielorOf is.i.optonNGINGte;
  }a;
r.optonNGINGt.tyeq)  alizif (!LE_IDhht = isForIis.tofi type true;
        cullet.optonNGINGall.idatelizif (!LE_IDhht = isForIaorIn i)O1; i classBody, "ClassBody");
  th"Crndi(and `ode(node, i.p(); }

    ifa;
rAL);
= 8 = th the precedence p 
  r which5)
  node.lOpst  default vaorIn i with 'let'."); }
    thity$1 mma emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.Na"sceL)e;
r f if (!LE_IDhht =Udaryde, init)
  } else {
     this.paeclaraaorIn i)O1;     node.e (seode(node, pIn(node, init)
  } else {
  pars Accessoe;
r   }
Accessoe;
rrorOf d retemerldYi.    ;
ri true;
   Arrowting it ode(node, i ?oe;
r : if (!LE_IDode(Op t;
rememerldYielorOf is.,t-1,baorIn i)AL);
= 8);
  t"))arytketutypesttowExtssSo tutypesprecedence p 
  reolonalgorowEm. `on m`.  /the sWithLet && isae, the ketutype wlse`minPrec` provsifsyue);
 ! ")
};
ons.secoveNC_HANGINrobsyppMEt olondthe/eNCr // t  
  r rob teae, itemove `r statnn itencout   seah
esto tutypes")
};hENTr os.tesprecedence rh
n the senainaisEp 
  re which5)
  node.lOpt  default von m

on mSmerldYielon mSmerlis.,tminPrec,baorIn i)ion")mma ire..ecmaVerurn Nbinopn(de= thire..!  ialis.eci!.orIn itility tot (td!return this_in)a >= 9 || thire..>tminPrec == types$1._cloge Par  if (!t (td return thisloge PaORaility tot (td return thisloge PaAND; types$1._ccoal'lc r  if (!t (td return thiscoal'lc ; types$>= 0eeal'lc ity$1 1 isssestH/ Pae the precedence key`ttscoal'lc `iENTeq)Par n
cover/ gt keyloge ParxpressionSs $1 1 isssestItIn // tt  //, `aratinitia``fhoulde'n" 'gaain loge ParxpressionSs iaynDd { to cidentrhetmixe

x {
  $1 1 isssire..ecmrn thisloge PaANDNbinopn(dethinstart, // A cps=e elseame) O1; i ss {
  tartNode());
 mma emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.Na"s);
 mma nitializif (!LE_IDode(Op if (!LE_IDhht =Udaryd types this.paeclaraaorIn i)ememerldYielorOf is.,tprec,baorIn i)Na"s);
 mma .ons.ecmaVerbuildB))ary(on mSmerldYielon mSmerlis.,ton m

nitia,  Oemloge Parilieeal'lc i; types$>= 0(loge ParNT) {
    nod return thiscual'lc ittruccoal'lc r.eciif (!t (td return thisloge PaORaility tot (td return thisloge PaAND))ity$1 1 issss.input.slucturingErromaVerorOf el"Loge ParxpressionSs et &coal'lc rxpressionSs 
    { 
  mixe
. Wrap`ei // tbyep
// partes"(element.start, /Accesso {
  turn ode(Op ;
  thon mSmerldYielon mSmerlis.,tminPrec,baorIn i)!thinstarrais
    ifon mAL);
ich5)buildB))aryt  default vemerldYielorOf is.,tsWit

nitia,  Oemloge Paity$1     nitiai true;
   Private if (!allowe{ break }
    nitiaiorOf el"Private sif (!allos
   o Rembe sWit&& isae, "))arytxpressionSent.star
 ! .ons.ecmaVerorOf = thAtvemerldYielorOf is.i.optaration may on m.optaratiretutypes=eopn(dearatinitializnitia;
i classBody, "ClassBody");
  thloge Par?l"Loge Paode(node, i : ".exaryode(node, i.pL);
= 8);
  tunarycretutypeielbo /e)..fix and postfix which5)
  nohht =U)aryt  default ve, init)
  } else {
    sawU)ary, sncDec,baorIn i)ion")mma emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.,}a;
r.opt    node.isde);
 ! eymarsion >t    {
  ean, thiity$1 1 e;
r f if (!LE_ID, thiIaorIn i)O1; i sawU)arynamu && !th}ontextual( {
    no.)..fixision >=
 ! .ons.ecmaVerorOf = th()emupxpre etuy tot (td return thissncDec.optonNGINGretutypes=e elseame) O1; i NGING)..fix amu && !thin {
  tartNode());aratireak`/`c
  if (!LE_IDhht =Udaryd typesa.un (upxpre,)aorIn i)O1; i  scope (seode(node, pIn(node, init)
  } else {
    this.c= 9 || thupxpreityh (refe (see
      // treatreak`/`cs FUNC_HAcmaVn)
};

pp$8lreadyNT)NGINGretutypes=
   dp
 tementthis.......));aratireak`/`ci true;
    if (!allowexpeDefint scoput.slucturingErro!node.handlerDp
 t) {
 ats.sv$1._in;tinClass DefiniaybFUNC_HAcmaVn)
};NGINGretutypes=
   dp
 tementaisPrivateFde, Accnod treatreak`/`csexpeDefint scoput.slucturingErro!node.handlerPrivate fde, s 
  "  { 
  dp
 tedaybFUNC_HAcmaVn{ sawU)arynamu && FUNC_HAc;
r f if (!ClassBody");
  thupxpre ?l"Upxpreode(node, i : "Uxaryode(node, i. !th}ontextual(!sawU)arynNT) {
    nod return thisprivate ia >= 9 || th(.orIn itility toprivateart,Smeckwitch ? ==1 0>t    {
  generatoesized=ivateFde, h { t scop {
      if (thi1 1 e;
r f if (!LE_IDPrivate if (Node());esto Remcould"
  private fde, s inC'in'elouchdENT#x iaynbj1; i >= 0 {
  t (td!return this_in){ t scop {
      if (thi1 rn(init);
   e;
r f if (!LE_IDode(Subatemptsde, init)
  } else {
     orIn i)O1; i >= 0node.e (seode(node, pIn(node, init)
  } else {
  pars Accessoe;
r   }
inssBody.body   no.)ostfixssElivateN
  In  rtSon(node, e == types$1._c;
  tion(maVerorOf = thAtvemerldYielorOf is.i.opton c;
  tiGretutypes=e elseame) O1; i  c;
  tiG)..fix amitkl-ca1 i  c;
  tiGreak`/`c
  a;
r.optonss {
  e (see
      // a;
rs.optssss {
  tartNode());
 c;
r f if (!ClassBody");
  $1,l"Upxpreode(node, ix bindin
isCa
ssual(!encDec     {
   his.parseStorOforOf)a >= 9 || thsawU)aryexpeDefint scop(statement  scopessBodySent)EwaitAt);cmaVersiofintclassBody, "buildB))ary(emerldYielorOf is.,tt;
remif (!LE_IDhht =Udaryd types this.paeclaraaorIn i)em"**hesdecl.ithi1 rn(init);
   
    ifa;
rAAt}
  reNC_HANGINkePrivateFde, Accnod treapty$1 Accessorthis.if (  ===  
   Memberode(node, iyNT)NGINGpr 0)
  i true;
   Private if (!allown = funcif (  ===  
   Chainode(node, ientaisPrivateFde, Accnod treatxpressionSm }
), ;
= 8);
  tove , doiEMEt e`[]`-subatemptrxpressionSs $hich5)
  node.lSubatemptst  default ve, init)
  } else {
    aorIn i)ion")mma emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.Na"sceL)e;
r f if (!LE_IDode(unctie, init)
  } else {
     orIn i)O1; lasst;
ri true;
   Arrowting it ode(node, i  === typennode) {
  ty toessBodySrOf temaVeressBodyEndod!ret")m;
(t(thi
    ife;
r   }
ceL)reaons{ybif (!LE_IDSubatemptsdt;
rememerldYielorOf is.,taeclaraaorIn i)O1;     ath 'let'."); }
    th  ==reaons  ===  
   Memberode(node, ia >= 9 || thith 'let'."); }
    thsp
// part ze
 isForE>==reaons orOf )thiith 'let'."); }
    thsp
// part ze
 isForE  -1 
C= 9 || thith 'let'."); }
    thsp
// part ze
.expd>==reaons orOf )thiith 'let'."); }
    thsp
// part ze
.expdvt-1 
C= 9 || thith 'let'."); }
    thstut.arseCuVar
>==reaons orOf )thiith 'let'."); }
    thstut.arseCuVar
To-1"nstarrais
    ifreaonsAL);
ich5)LE_IDSubatemptst  default vb is.pemerldYielorOf is.,tnoCve s  aorIn i)ion")mma mht = iyncArrow{ybif (!generator = this.eat(ty8  ==b isi true;
    if (!allow  ==b isi.lastT eleriyncmentthis...maVeressBodyEndtT elb isi;t |sElivateN
  In  rtSon(node, e  ==b isi;t |- b isiorOf d ret5entthis...maVertot if alArrowAt.e elb isiorOf ;de./ A cp(and `Chaintrnamitkl-ca
inssBody.bhis.s$1.braceL);
e`/`c
  if (!LE_IDSubatemptvb is.pemerldYielorOf is.,tnoCve s  mht = iyncArrow, cp(and `ChaintrraaorIn i)O1= 9 || thp
      cp(and `)thicp(and `Chaintrnamu && FUNC_HA| thp
     .e elb istilip
       true;
   Arrowting it ode(node, i { est(t(t
   cp(and `ChaintreinIdment)) ceL)chainNons.ecmaVerorOf = thAtvemerldYielorOf is.i.optonnnnnchainNonstxpressionS
  a
     .optonnnnn;
e`/`c
  if (!ClassBody")chainNons,  Chainode(node, i(element.start, /Accesso;
e`/`cbindin
bindib ist  a
     .opt}AL);
ich5)fhouldPurn -oyncArrow{ybdefault mpty$1 AccessoivateN
  In  rtSon(node, e  == {
   his.parseStarrowabL);
ich5)LE_IDSubatempt-oyncArrow{ybdefault memerldYielorOf is.,tt;
rL);


aorIn i)ion")Accesso {
  turn Arrowode(node, (maVerorOf = thAtvemerldYielorOf is.i,tt;
rL);


a.un (dorIn i)AL);
ich5)LE_IDSubatemptt  default vb is.pemerldYielorOf is.,tnoCve s  mht = iyncArrow, cp(and `ChaintrraaorIn i)ion")mma cp(and `Suple'"trnamuf (!generator = this.eat(ty11;de./ A cp(and `s=eop(and `Suple'"trn == {
   his.parseStq) s(eleDoi)O1;     noCve syNT)cp(and `)thireak }
    ty toessBodySrOf te O (and `bchain!node.   { appefDesttrhetove `sae, new=xpressionSs" (thi   1._ccoies ose== {
   his.parseSt.typketL)O1;      ties oseili cp(and `ent.    if (th
  this.exper 1ibcant.    if (th
  this.expebackQuote)tility to his.parseStdotaision >=
 ! .ons.ecmaVerorOf = thAtvemerldYielorOf is.i.optonNGINGr.pars
elb isO1; i >= 0 ties oseinIdment)NGINGpr 0)
   f if (!LE_IDode(node, (s.optssss {
   true;
        .typketR1.braceContextual( {
    nod return thisprivate i  ==b isi true!ret"Suplowe{ Idment)NGINGpr 0)
   f if (!LE_IDPrivate if (Node());Context est(t(tNGINGpr 0)
   f if (!LE_ID if (Nuf (!generato
ons.R.  rv i !ret"nev {hisbindin
isonNGINGt.ies ose==!!t.ies osO1; i >= 0ep(and `Suple'"tre{ Idment)NGINGcp(and `s=eop(and `sbindin
isonb ist  dy, "ClassBody");
  th"Memberode(node, ia !th}ontextual(!noCve syNT)ty to his.parseStr 1ibcaision >=
 ! ath 'let'."); }
    th = new= 'let'."); }
    th,beenYtemedYi.ecmaVerytemedYi,been, thidYi.ecmaVera thidYi,been, thi if (dYi.ecmaVera thi if (dYiO1; i  scopytemedYi.ec0O1; i  scopa thidYi.ec0O1; i  scopa thi if (dYi.ec0O1; i ceL)e;
r(typ{ybif (!LE_IDode((types$1.parenL);
 ,bif (!generator = this.eat(ty8

start with 'let'."); }
    this1; i >= 0mht = iyncArrow{sElicp(and `ent.    ifhouldPurn -oyncArrow e == types$ {
  e (sedecl.idpIn(node, init)
  } else {
    decl.i.optonss {
  e (seYteme, thi n);tionsPion s(i; types$>= 0 scopa thi if (dYi.> 0test(ttttt break }
     scopa thi if (dYilerC    { ;
  'rsion'MENT`       thiinunctismentsGod
    { this.raisssss scopytemedYi.eceenYtemedYi.optonss {
  a thidYi.eceen, thidYi.optonss {
  a thi if (dYi.eceen, thi if (dYi.optonssAccesso {
  turn Subatempt-oyncArrowmemerldYielorOf is.,tt;
rL);


aorIn i)bindin
ison scope (seode(node, pIn(node, init)
  } else {
    this.c= 9 | scopytemedYi.eceenYtemedYitility toytemedYi.opton {
  a thidYi.eceen, thidYitility toa thidYi.opton {
  a thi if (dYi.eceen, thi if (dYitility toa thi if (dYi.opton1._c;
  tion(maVerorOf = thAtvemerldYielorOf is.i.opton;
  tiGove `saelb isO1; i ;
  tiGreak`/`cs | a;
rL);
O1; i >= 0ep(and `Suple'"tre{ Idment)NGINtiGre(and `s=eop(and `sbindin
isonb ist  dy, "ClassBody");
  $1,l"Cve ode(node, ia !th}ontextual( {
    nod return thisbackQuote)t{1; i >= 0ep(and ` ilicp(and `ChaintreinIdment)reak }
     scopsrOf te O (and `bchain!node.   { appefDesttrhettagae, taggtrite  /tor=xpressionSs" (bindin
ison1._c;
  t2on(maVerorOf = thAtvemerldYielorOf is.i.opton;
  t2.tagaelb isO1; i ;
  t2tq)asi{ybif (!LE_IDTe  /tor({isTaggtr: this} ;tAt);o ist  dy, "ClassBody");
  $2te TaggtrTe  /torode(node, ia !th}n")Accessoo isAL);
= 8);
  tanesncticLabelssionSt—Nei // t
   relsS t mas")
};iseah
estabelssionS,Tr LabelssionStorOf edsby a n this.rt)kee`
    { t`|or a ``new`}
 );s LabelssionStwrapptriin p    ulse {
t)kee`()`}
`[]`,
este.b`{}` $hich5)
  node.lunct{ybdefault ve, init)
  } else {
     orIn i   orNewsion")= 8IfessdivitsleaeetutypesappefDs  reahLabelssionStmenh(eleect t
")= 8 rkmaiz/ tgon" 'gfu  dEMEt &ws.de.c  inaratr ("n
mentt;
; typ (".ue;
    {
    nod return thisstexh)thireak } ("Rntt;
( (thi   1._c;
  the. BeArrow{ybif (!tot if alArrowAt.e elmaVerorOf  !thehis.ty     if (tsion") typeurn this_suplo:aisssat iivateN
ons.SuploexpeDefint scoput.sl  scopsrOf te 'suplo' n this.routunctis on ete"s FUNC_HAarat.ecmaVerorOf = th() !thin {
  tartNode());    node.t (td return thisr 1ibcasElivateN
ons.DiowSuSuploexpeDefint scoput.sl !node.handlersuplo e caonaeutunctit.type ==pesStaINsubxt();"s FUNC_HAlsedssS`suplo` n this.r
   appefDe
};bens.:lemenis.Suplo  returt:lemenis.....suplo [ ode(node,  ]lemenis.....suplo .  if (!alloart,lemenis.SuploCve :lemenis.....suplo ( Aeak`/`cs )e());    node.t (td!return thisdotant.    if (th
  this.expebtypketLent.    if (th
  this.exper 1ibcexpeDefint scop(statement nt.start,classBody, "ClassBody");
  th"&uplowe
n") typeurn this_dy, :NC_HAarat.ecmaVerorOf = th() !thin {
  tartNode());classBody, "ClassBody");
  th"ThhiE;
rnode, i.pn") typeurn this.las:
ison1._cemerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.,} 'gaainsEs..ecmaVer 'gaainsEs..opton1._cid f if (!LE_ID if (Ndecl.i.opton    node.generator = this.eat(ty8  ==! 'gaainsEs..ntaidi.lastT eleriyncmentoivateN
  In  rtSon(node, e  == {
   his.parseStreturn th.einIdment)reak urinri  de);
 !r rn t.f_t;
r);optonssAccesso {
  turn ting it (maVerorOf = thAtvemerldYielorOf is.i,t0

start wa.un (dorIn i)Aindin
ison>= 0 . BeArrow{sElivateN
  In  rtSon(node, e == types$    node.this.parseStarrowatest(ttttt bAccesso {
  turn Arrowode(node, (maVerorOf = thAtvemerldYielorOf is.i,t[id],taeclaraaorIn i)in
israHAat inode.generator = this.eat(ty8  ==idi.lastT eleriyncmentonode.t (td return thisaels    ! 'gaainsEs..ntest(ttttt  iivateNtot if alArrowInFor, thinility toame) {!  rnof"sility to 'gaainsEs.)ity$1 1 isssid f if (!LE_ID if (Ndecl.i.optonraHAat inode.
  In  rtSon(node, e    }.finishNode(decl,arrowatest(tttttfint scop(statement nt.start,onssAccesso {
  turn Arrowode(node, (maVerorOf = thAtvemerldYielorOf is.i,t[id],ta.un (dorIn i)Aindidin
isonstart,classBoidpn") typeurn thisentt;
:
ison1._came) {
e elseame) O1; i NGIN f if (!LE_IDLaultPa(ame) same) )n
isonNGINGentt; f {      t:came) .      t (dlags:came) .dlags}de());classBonons

") typeurn this.um:) typeurn thiss { re:e());classBody, "LE_IDLaultPa( elseame) e
n") typeurn this_ typ:) typeurn this_d.un:) typeurn this_decl.:NC_HAarat.ecmaVerorOf = th() !thinNGINGame) {
e elset (td return this_ typ ? ialis:e elset (td return this_u && !thinNGINGeaw{
e elset (trn this. !thin {
  tartNode());classBody, "ClassBody");
  th"LaultPame
n") typeurn thisr 1ibc:
ison1._cemerl.ecmaVerorOf ele;
r f if (!LE_IDP
//  ndDitu reussBode(node, ( . BeArrow   orIn i)O1; i >= 0ith 'let'."); }
    thity$1 1 is| thith 'let'."); }
    thsp
// part ze
 isForE< 0{sElivateNis    // isForTarget a;
rstest(ttttt bAch 'let'."); }
    thsp
// part ze
 isForE  orOf  in
israHAat iith 'let'."); }
    thsp
// part ze
.expd< 0test(ttttt bith 'let'."); }
    thsp
// part ze
.expdvtorOf  in
israstart,classBoa;
rAn") typeurn thisbtypketL:NC_HAarat.ecmaVerorOf = th() !thin {
  tartNode());treatxlingCos{ybif (!LE_IDode((types$1.pare.typketR  this  this.pith 'let'."); }
    this1; i classBody, "ClassBody");
  th"AhNodE;
rnode, i.pn") typeurn thisalse;
:aisss {
  urinri  de);
 !r rn t.b_t;
r);optonclassBody, "LE_IDObj(start with 'let'."); }
    thi
n") typeurn this_eturn th:NC_HAarat.ecmaVerorOf = th() !thin {
  tartNode());classBody, "turn ting it (;
  th0i
n") typeurn this_xt();:e());classBody, "LE_IDntexs(maVerorOf = th()  decl.i
n") typeurn this_ ew:e());classBody, "LE_IDNew(.pn") typeurn thisaackQuote:e());classBody, "LE_IDTe  /tor(i
n") typeurn this_dule'":lemen)
};

pp$generator = this.eat(ty11 { est(t(trecesso {
  turn ode(Iule'"( orNews
israsontext est(t(trecesso {
  (statement n
israst
iodpis.ra:aisssrecesso {
  turn ode(unct);tions(.p(); L);
ich5)LE_IDode(unct);tions{ybdefault mpty$1  scop(statement nt L);
ich5)LE_IDode(Iule'"t  default vaorNewsion")
 ! .ons.ecmaVerorOf = th(); } elsede)sk`/T`dule'"`iENT
n sif (!allosde.b`dule'".on a`.ue;a `e ca;
  `if (!LE_ID if (Nuhis.` doe/e'n"cidentescanodseq)  css,e=t needsecovecidentkey`ty to 'gaainsEs.`.ue;
    {
   'gaainsEs.)int scoput.slucturingErro scopsrOf te Escanodseq)  cs  ren this.rdule'""t;(onsequenttartNodeue;
    {
    nod return thisr 1ibcasEliaorNewsion")ssrecesso {
  turn DyaelicIule'"(treap!th}ontextual( {
    nod return thisdota >= 9 |mma mn aon(maVerorOf = thAtv!node.handlearatioocyNT)NGINGoociment)Ew= 9 |mn a..lastTo"dule'""de());treatmn aon(maVerClassBody")mn a,   if (!allowede());classBody, "turn Iule'"Mn a(treap!th}ontext{!thin {
  (statement nt (); L);
ich5)LE_IDDyaelicIule'"t  default vtreapty$1 quenttartNod;a `skip `(` } else);
  t!node.ource.ue;!node.ourcelizif (!LE_IDhht = isForIis.} elsethii(yse))) {.ue;
   }.finishNode(decl,nL);
 aision >=
 ! x {
 dYi.ecmaVerorOf .opton    node.shNode(decl, "VariyNT)ty to his.parseStr 1ibR.einIdment)reak   if ucturingErroa {
 dYith"Tut.arse  "VarE  // ttePns.tri redule'"()" (bindinontext est(t(t {
  (statement a {
 dYix bindin
isCa
ssclassBody, "ClassBody");
  th"Iule'"ode(node, i.pL);
ich5)LE_IDIule'"Mn at  default vtreapty$1 quenttartNod;a `skip `.`i   1._ccogaainsEs..ecmaVer 'gaainsEs..optNGINGpr 0)
   f if (!LE_ID if (Nuhis.c=
;     noINGpr 0)
  i.last!  rnmn am;
(t(thireak   if ucturingErronoINGpr 0)
  isrOf te dssSo Remameid mn aopr 0)
   de.bdule'"E  /'dule'".on a'"i.true;
    'gaainsEs.)
(t(thireak   if ucturingErronoINGsrOf te 'dule'".on a' must// tt 'gaain escanodbchalse   s"i.true;
   if (!generato.ourceT (td!ret"modulementoivateNgenerato
ons.Iule'"odee'"orinytatrf)
(t(thireak   if ucturingErronoINGsrOf te C    { ;
  'dule'".on a' outunctis oodulem (thi   classBody, "ClassBody");
  th"Mn a  returtm.pL);
ich5)LE_IDLaultPat  default vame) eion")
 ! .ons.ecmaVerorOf = th(); inNGINGame) {
eame) O1; NGINGeaw{
e elseennode) {
  ty tosrOf temaVere)))O1;     noINGeaw.chalC thAtv!nodeeaw.itch ? - 1od ret110ableNGINGbigi`c
  !nodeeaw.) {
  0,t-1)Gen /t
  /_/gth""t;(onsequenttartNode);classBody, "ClassBody");
  th"LaultPame
L);
ich5)LE_IDP
// de.lssionSt  default vpty$1 quent true;
        r 1ibce;de./ A vPar  if (!LE_IDode(node, (s.optquent true;
        r 1ibRode);classBovPaAL);
ich5)fhouldPurn -rrow{ybdefault ma;
rL);
pty$1 AccessoivateN
  In  rtSon(node, e
L);
ich5)LE_IDP
//  ndDitu reussBode(node, {ybdefault m . BeArrow   orIn i)ion")mma emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.,}vPa,tePns.Tut.arseCuVarE  node.generator = this.eat(ty8;ue;
   if (!generator = this.eat(ty6sion")ioquenttartNodeue;r i = ;nnerSmerldYi.ecmaVerorOf el;nnerSmerlis..ecmaVerorOf is.Na"s);ceL)e;
r(typ{yb[],tairsinamu &&, essBIsCuVarE  itkl-ca1 i 
 ! ath 'let'."); }
    th = new= 'let'."); }
    th,beenYtemedYi.ecmaVerytemedYi,been, thidYi.ecmaVera thidYi,bsp, ("SrOf .optonmaVerytemedYi.ec0O1; i  scopa thidYi.ec0O1; i a `Doi) {
saveea thi if (dYi.totePns.eciden!nod
 thisbnetutriin pion or ls1; i ssBody.body   noh
  this.exper 1ibReinIdment)airsin?tairsinamaeclas:tquent true;
         "Vari; types$>= 0ePns.Tut.arseCuVarENT)ty to    {Tut.arseCuVares$1.parenL);
 ,bihis.ity$1 1 isssessBIsCuVarE  e && !thindi .op"))
raindinontext>= 0 {
  t (td return thisellipsihity$1 1 issssp, ("SrOf .ecmaVerorOf .optonnnnne;
r(typ (!cur {
  turn P
// Itemr {
  turn Rest.expect())i.optonraHAat inode.t (td return thiscuVarision >=dment)reak   if ucturingErroon >=dment) cmaVerorOf eon >=dment) c"C"VarE  // ttp lmitttriE   {ecovere;
 xlingCo"on >=dment)(element.) At); }
  .op"))
raindinontext{optonnnnne;
r(typ (!cur {
  turn hht = isForIatart with 'let'."); }
    themif (!LE_IDP
// Item)i.optonran
israstart,i = ;nnerEnedYi.ecmaVeressBodyEndte;nnerEneis..ecmaVeressBodyEndis.Na"s);quent true;
        r 1ibRodeopton     . BeArrow{sElmaVerohouldPurn -rrowma;
rL);
pt == {
   his.parseStarrowa == types$ {
  e (sedecl.idpIn(node, init)
  } else {
    decl.i.optonss {
  e (seYteme, thi n);tionsPion s(i; types$maVerytemedYi.eceenYtemedYi.optonss {
  a thidYi.eceen, thidYi.optonssclassBody, "turn P
//  rrow(typeemerldYielorOf is.,tt;
rL);


aorIn i)bindin
opton    !e;
r(typ itch ? ||sessBIsCuVar){ t scop {
      ifmaVeressBodySent)EwaitAt);| thsp, ("SrOf ){ t scop {
      ifsp, ("SrOf );in
ison scope (seode(node, pIn(node, init)
  } else {
    this.c= 9 | scopytemedYi.eceenYtemedYitility toytemedYi.opton {
  a thidYi.eceen, thidYitility toa thidYi.otAt);| the;
r(typ itch ? > = == types$1.l.ecmaVerorOf = thAtv;nnerSmerldYiel;nnerSmerlis.)Na"s);
 mmlGxpressionSs;= a;
rL);
O1; i  ody, "ClassBody"AtvvPa,t"&eq)  csode(node, i, ;nnerEnedYite;nnerEneis. (bindinontext est(t(t1.l.eca;
rL);
[0] !thinstarnontext est(tvPar  if (!LE_IDP
// de.lssionS nt (); ue;
   if (!generatope.  rv P
// sision >=
 ! LE_on(maVerorOf = thAtvemerldYielorOf is.i.optonLE_txpressionS
  v `sbindiclassBody, "ClassBody")LE_lerP
// part ze
ode(node, i.p1 rn(init);
   
    ifvPaA(); L);
ich5)LE_IDP
// Item{ybdefault mitem)ty$1 Accessoitem
L);
ich5)LE_IDP
//  rrow(typ{ybdefault memerldYielorOf is.,tt;
rL);


aorIn i)ion")Accesso {
  turn Arrowode(node, (maVerorOf = thAtvemerldYielorOf is.i,tt;
rL);


aeclaraaorIn i)AL);
= 8New's precedence   /) {ghuly
ass ky. It must/ePns.eico;

ak`/`c
toolonbtis `[]` e.bdotasubatemptrxpressionS, 
uto/ tte caona—N
t lessB,
est/ tttowEcu! wrapp!noditiin pio/ partes.edsus,e=t  ststthe .oCve solona
ak`/`c
to LE_IDSubatemptstto Lrev    itt`in` ce)sk`!nodrh olona
ak`/`c
ltyp ind ==emp   f []);
ich5)LE_IDNewt  default vpty$1 
    {
   'gaainsEs.)int scoput.slucturingErro scopsrOf te Escanodseq)  cs  ren this.rnewent.star
 ! .ons.ecmaVerorOf = th(s.optquenttartNode);    node.generator = this.eat(tyns.ec {
    nod return thisdota >= 9 |mma mn aon(maVerorOf = thAtv!node.handlearatioocyNT)NGINGoociment)Ew= 9 |mn a..lastTo"newede());treatmn aon(maVerClassBody")mn a,   if (!allowede()); {
  tartNode());1._ccogaainsEs..ecmaVer 'gaainsEs..optptNGINGpr 0)
   f if (!LE_ID if (Nuhis.c=At);| thnoINGpr 0)
  i.last!  rntargetwexpeDefint scoput.slucturingErro!nodepr 0)
  isrOf te dssSo Remameid mn aopr 0)
   de.bnew=  /'new.target'"EwaitAt);| th 'gaainsEs.)
(t(t(thireak   if ucturingErronoINGsrOf te 'new.target' must// tt 'gaain escanodbchalse   s"i.true;ssat iivateN
ons.NewDotTarget)
(t(t(thireak   if ucturingErronoINGsrOf te 'new.target' 
   o Rembe  stri refC_HANGI set &ct();
srOse {beat("nt.start,classBody, "ClassBody");
  th"Mn a  returtm.pt(onse
 ! emerldYi.ecmaVerorOf elorOf is..ecmaVerorOf is.Na"sNGINGtve `saelif (!LE_IDSubatemptsd {
  turn ode(unctd types this.puhis..pemerldYielorOf is.,ta.un (decl.i.opt    node.shNode(decl,r 1ibcaisi;aratireak`/`cs{ybif (!LE_IDode((types$1.parenL);
 ,bif (!generator = this.eat(ty8

startme(onsentexsi;aratireak`/`cs{ybemp  c.rais
    ifdy, "ClassBody");
  th"Newode(node, i.pL);
= 8);
  tte  /tor=xpressionS $hich5)
  noTe  /toro
e`/`c
  default ve, )ion")mma isTaggtr Toith.isTaggtr;i   1._cxlin.ecmaVerorOf = th(s.optat inode.t (td return thisinameidTe  /tor)t{1; i >= 0!isTaggtreinIdment)reak   if ucturingErro scopsrOf te Badtescanodseq)  csi reuntaggtrite  /tor=laultPame(bindin
isonxlinGame) {
e est(t(traw:e elseame) eon >=dmcooktr:  typbindin !th}ontext{
isonxlinGame) {
e est(t(traw:e elseennode) {
  ty tosrOf temaVere)))Gen /t
  /\r\n?/gth"\ i.eon >=dmcooktr:  elseame) bindin !th}optquenttartNode);xlinGaaiar  if (!t (td return thisaackQuotede);classBody, "ClassBody")xlinte de  /toro
e`/`cme
L);
ich5)LE_IDde  /tor
  default ve, )ion")>= 0oithd retvoid 0 )oithd  {};n")mma isTaggtr Toith.isTaggtr;)>= 0oisTaggtr Tretvoid 0 )oisTaggtr Toitkl-ca
in
 ! .ons.ecmaVerorOf = th(s.optquenttartNode);treatxpressionSs f []););1._ccurEns{ybif (!LE_IDde  /toro
e`/`c({isTaggtr: isTaggtr}ode);treatq)asis f [curEns]););ssBody.!curEnsGaaiaa >= 9 || this.opt (td return thiseof)thireak }
    ty topYith"Ut   `!nLevdite  /tor=laultPame(in
ison scop true;
        dollarBlse;
i.optonNGINGxpressionSs (!cur {
  turn de.lssionS nis.tofi type true;
        ct(typi.optonNGINGq)asis (!curcurEns{ybif (!LE_IDde  /toro
e`/`c({isTaggtr: isTaggtr}o) !th}optquenttartNode);classBody, "ClassBody");
  th"Te  /torLaultPame
L);
ich5)n erync  re
  default vpr 0pty$1 Accessoi). O. ties ose.ec). O or = true;
    if (!allow  ==). O or =.lastT eleriyncmentthis.his.opt (td return this.lastility tot (td return this umtility tot (td return thiss { retility tot (td return thisbtypketLeility tot (trn this.eili if (!generator = this.eat(ty9s.ec {
    nod return thisorOf)a ntthis.!'ineBp"))t = futy to inode) {
  ty toessBodyEndtemaVerorOf ))AL);
= 8);
  taner.pars
laultPa e.bbexpect
      t $hich5)
  noObj{ybdefault misP     t (ith 'let'."); }
    thity$1 mma .ons.ecmaVerorOf = th(s,tairsinamu &&, te OHexhd  {};n")!nodepr 0)
 ies;f []););quenttartNode);ssBody.!node.shNode(decl,ct(typi)t{1; i >= 0!airsieinIdment)reak  true;
         "Vari; types$>= 0if (!generator = this.eat(ty5ENT)ty to    {Tut.arseCuVares$1.parect(typi)t{.op"))an
israsentexsi;airsinamaecla;in
optonmma ircps=e elseLE_IDPrreturtmisP     t (ith 'let'."); }
    thic=At);| th!isP     tityh (refe (sed=opntexhxte Oemte OHexh with 'let'."); }
    thi FUNC_HAaratipr 0)
 ies (!curpr 0p !th}optclassBody, "ClassBody");
  thisP     t ?l"8.parsP     ti : "8.parsode(node, i.pL);
ich5)LE_IDPr 0)
   f default misP     t (ith 'let'."); }
    thity$1 mma ircps=e elseorOf = th(s,tis.eat(type,tiserync.pemerldYielorOf is.de);    node.generator = this.eat(ty9t == {
   his.parseStellipsihi)t{1; i >= 0isP     tity types$). O reak`/`c
  if (!LE_ID if (Ndecl.i.optonraat inode.t (td return thiscuVarision >=dmenreak   if ucturingErro scopsrOf te C"VarE  // ttp lmitttriE   {ecovere;
 xlingCo"(element.start, /Accesso {
  ClassBody")Le Oem"RestElingCom;
(t(tUNC_HAlse);
  taeak`/`ci
pes$). O reak`/`c
  if (!LE_IDhht = isForIatart with 'let'."); }
    thode());estTo disePns.etut.arse  "VarEviay`ty to r-of loop ma)`.= 9 || this.opt (td return thiscuVarENT)ath 'let'."); }
    th  ==reh 'let'."); }
    thstut.arseCuVar
< 0ity$1 1 isith 'let'."); }
    thstut.arseCuVar
TomaVerorOf .optonUNC_HAlseFlassBbindiclassBody, "ClassBody")Le Oem"&p, ("ElingCom;
(t}a1     node.generator = this.eat(tynity$1 1 ). O.on ete   itkl-ca1 i ). O.shorrh
nd   itkl-ca1 i >= 0isP     teiliith 'let'."); }
    thity$1 1 isemerldYi.ecmaVerorOf ;$1 1 isemerlis..ecmaVerorOf is.Na"s);}=At);| th!isP     ti
(t(t(thiis.eat(type.ecmaVer his.parseStorOf.c.raisrue;1._ccogaainsEs..ecmaVer 'gaainsEs..opt elseLE_IDPrreturtart,rpr 0p !th| th!isP     t  ==! 'gaainsEs..ntaif (!generator = this.eat(ty8  ==!is.eat(type. === type erync  rerpr 0p)t{1; i > eryncE  e && !thinis.eat(type.ecmaVergenerator = this.eat(ty9t == {
   his.parseStorOf.c.tofi typeLE_IDPrreturtart,rpr 0p !thrn(init);
   > eryncE  itkl-ca1 }opt elseLE_IDPrreturtVme) )Le OemisP     t (is.eat(type,tiserync.pemerldYielorOf is. with 'let'."); }
    them 'gaainsEs.)de);classBody, "ClassBody")Le Oem"  returtm.pL);
ich5)LE_IDGs.  {Ss.  {
  default vpr 0pty$1 ). O. f ( ==). O or =.las.opt elseLE_IDPrreturtart,rpr 0p !th). O ame) {
e elseLE_IDhn eteNdecl.i.opt
 ! LE_amCout  = ). O. f ( = elegetw ?l0 : 1");
    ). O ame) .LE_ams itch ? !  rLE_amCout a >= 9 |mma emerl.ec). O ame) .orOf .opton    ). O. f ( = elegetw)
(t(t(thireak   if ucturingErrosrOf te is.  {`fhould haveenorLE_ams"EwaitAt);cmaVersiofintreak   if ucturingErrosrOf te ss.  {`fhould haveeexaSulyb teaLE_am"(ensAsVae clas{s.typ    ). O. f ( = elesetw  ==). O ame) .LE_ams[0]= true;
   RestElingCom;
(t(tfintreak   if ucturingErro). O ame) .LE_ams[0]=srOf te Ss.  {
c    { ;
  re;
 LE_ams"EwaitAt; L);
ich5)LE_IDPrreturtVme) 
  default vpr 0emisP     t (is.eat(type,tiserync.pemerldYielorOf is. with 'let'."); }
    them 'gaainsEs.)ion")>= 0(is.eat(type.iliiserync)s.ec {
    nod return thiscullet
(tfintreak (statement nt.stopt    node.shNode(decl,culletity$1 1 ). O.ame) {
eisP     t ?lif (!LE_IDhht =);tions(ty tosrOf temaVerorOf is.i : if (!LE_IDhht = isForIatart with 'let'."); }
    thode());). O. f ( ==(ush(  !thrn(init    node.generator = this.eat(tyns.ec {
    nod return thisr 1ibcat{1; i >= 0isP     titytreak (statement nt.st());). O. f ( ==(ush(  !th1 ). O.on ete   e && !thin). O ame) {
e elseLE_IDhn eteNis.eat(type,tiserynca !th}ontextual(!isP     t  ==! 'gaainsEs..nton >=dmen=dmenreak generator = this.eat(ty5ENT)i). O. ties ose.ec). O or = true;
    if (!allow  =on >=dmen=dmen(). O or =.lastT elegetw ili). O.or =.lastT elesetw)  =on >=dmen=dmen( {
    nod!return thiscuVarENT) {
    nod!return thisct(typENT) {
    nod!return thiseqi)t{1; i >= 0is.eat(type.iliiserync)sytreak (statement nt.st()); elseLE_IDGs.  {Ss.  {rpr 0p !thrn(init    node.generator = this.eat(tyns.eci). O. ties ose.ec). O or = true;
    if (!allow)t{1; i >= 0is.eat(type.iliiserync)sytreak (statement nt.st()); elsee (seUne.  rv d(). O or ).opton    ). O. r =.lastT elersion asElivateN
 thi if (dYi;
(t(tfintreak a thi if (dYi.ecemerldYit.st());). O. f ( ==(ush(  !th1 >= 0isP     tity types$). O ame) {
e elseLE_IDhht =);tions(emerldYielorOf is.,taaVer 'pyody")Le O or )1.braceContextual( {
    nod return thiseq  ==reh 'let'."); }
    thity$1 1 is| thith 'let'."); }
    thsshorrh
nd isForE< 0test(ttttt bith 'let'."); }
    thsshorrh
nd isForETomaVerorOf ;.start, /). O ame) {
e elseLE_IDhht =);tions(emerldYielorOf is.,taaVer 'pyody")Le O or )1.braceContexty types$). O ame) {
e else 'pyody")Le O or )Na"s);}=At);). O.shorrh
nd   u && !th}ontextytreak (statement nt.stL);
ich5)LE_IDPrreturtNlastTodefault vpr 0pty$1     node.generator = this.eat(tynity$1 1     node.shNode(decl,.typketL)ity types$). O coies ose==  && !thindiLe O or lizif (!LE_IDhht = isForIis.n=dmenreak  true;
        .typketR1.brace);classBoLe O or braceContexty types$). O coies ose==itkl-ca1 i starrais
    ifLe O or lizif (!t (td return this umtility tot (td return thiss { ret?lif (!LE_IDode(unctdi : if (!LE_ID if (Nuf (!generato
ons.R.  rv i !ret"nev {hiAL);
= 8In ii+ " e=emp   NC_HANGINarati;
ich5)nn iting it t  default vtreapty$1 aratiid f  typde);    node.generator = this.eat(tynisi;aratigeat(type.ecNGINGxpressionSnamaecla;in
HAat inode.generator = this.eat(ty8isi;aratirryncE  itkl-c.stL);
lse);
  tr.pars
pe.ct();
on ete which5)
  nohn ete   iefault mis.eat(type,tiserync.p
ons.DiowSuSuploety$1 mma .ons.ecmaVerorOf = th(s,teenYtemedYi.ecmaVerytemedYi,been, thidYi.ecmaVera thidYi,been, thi if (dYi.ecmaVera thi if (dYiO1opt elsenn iting it vtreapde);    node.generator = this.eat(tyni
(tfintaratigeat(type.ecis.eat(type;in
HAat inode.generator = this.eat(ty8i
(tfintaratirryncE  !!iserynct.stoptmaVerytemedYi.ec0O1; maVera thidYi.ec0O1; maVera thi if (dYi.ec0O1; maVere)  {S 'pe(iefault Flags(iserync.paratigeat(type) | SCOPE_SUPER | (
ons.DiowSuSuplot?lSCOPE_DIRECT_SUPER : 0t)O1opt else true;
        r 1ibce;de.aratipE_amslizif (!LE_ID.expect(types$1.parenL);
 ,b this.puode.generator = this.eat(ty8iO1; maVere (seYteme, thi n);tionsPion s(i; tyif (!LE_IDting it Body);
  thstart wa.un (decl.i.ooptmaVerytemedYi.eceenYtemedYi.optmaVera thidYi.eceen, thidYi.optmaVera thi if (dYi.eceen, thi if (dYi.optclassBody, "ClassBody");
  th"ting it ode(node, i AL);
= 8);
  tarrow{NC_HANGINabelssionStwowExgiven pion or ls which5)
  noArrowode(node, t  default vtrea, LE_ams,tiserync.paorIn i)ion")mma cenYtemedYi.ecmaVerytemedYi,been, thidYi.ecmaVera thidYi,been, thi if (dYi.ecmaVera thi if (dYiO1opt elsee)  {S 'pe(iefault Flags(iserync.pdecl.it| SCOPE_ARROWi; tyif (!nn iting it vtreapde);    node.generator = this.eat(ty8isi;aratirryncE  !!iserynct.stoptmaVerytemedYi.ec0O1; maVera thidYi.ec0O1; maVera thi if (dYi.ec0O1de.aratipE_amslizif (! r-of loop m(typeLE_ams,tuhis.c=Atif (!LE_IDting it Body);
  tha.un (decl.raaorIn i)O1= 9maVerytemedYi.eceenYtemedYi.optmaVera thidYi.eceen, thidYi.optmaVera thi if (dYi.eceen, thi if (dYi.optclassBody, "ClassBody");
  th"Arrowting it ode(node, i AL);
= 8);
  tNC_HANGINbodyset &cidentpion or ls which5)
  noting it Bodyt  default vtrea, iserrowting it , ishn ete.paorIn i)ion")mma hiE;
rnode, .eciserrowting it ENT) {
    nod!return thisct(tyL;n")mma cenSass DeecmaVerorss D, ;
 Sass Deecitkl-ca
in>= 0isE;
rnode, ity typeNGINGbodyt  if (!LE_IDhht = isForIaorIn i)O1; i NGINGxpressionSnamu && !thin {
  e (sedeon s(;
  thstartp !thrn(init);
   mma .on    //.ecmaVergenerator = this.eat(ty7{sElivateNis    //deon (typearatipE_amsic=At);| th!cenSass Deili.on    //ity types$;
 Sass DeecmaVerorss DDiowSuive node.s)))O1;     = 8Ifenode;iseaClass Defini default , vhii(ys")
};
eak`/`c
.lass1;     = 8L);// ttrepeLevdEMEt &it doe/// tttrytto bexpecovet  // `eame`1;     = 8e.b`reak`/`cs` $1 1 is| thu
 Sass DeNT)NGn    //iest(ttttt break   if ucturingErronoINGsrOf te Illegal ';
  sass D' diowSuivei refC_HANGItwowExNGn-s   //.pion or l
ltyp"EwaitAt);UNC_HAlseSrOf .abnew=s 'petwowExregardtto lab(inMEt &cove`inting it `NC_HAlsedlagthitsypee themr n
covia cencame) {E   {wards).;
   mma cenLab(inMecmaVeresb(in !thin {
  lab(inMec[]c=At);| thu
 Sass D)sytreak sass Deecm && FUNNC_HAlseAd &covepE_amsl n
mmaDect(redNlassl n
ensuee th
};
n x {
 .  /thrownNC_HAlseitaINlet/t.typ dect(rlse {
sttrhetfC_HANGItct()hesttowEx teae, covepE_ams.!thin {
  e (sedeon s(;
  th!cenSass DesEliu
 Sass DeNT)!iserrowting it ENT)!ishn ete. === type     //deon (typearatipE_amsiode());estEnsuee thetfC_HANGIt.lasti/e'n"apaorbiddenT`       thiinClass Defini, tig. 'eame'$1 1     node.8lreadyNT)NGINGidityh (refe (see
      // treatidEMBIND_OUTSIDEi FUNC_HAaratibodyt  if (!LE_IDBeat(Iatart wundefintrrau
 Sass DeNT)!cenSass D)O1; i NGINGxpressionSnamitkl-ca1 i maVeradapDDiowSuivePrologu/ treatbodytbody) !thin {
  lab(inMeccenLab(inca1 }opt elseexitS 'pe(nt L);
ich5)e     //deon (typtTodefault vpE_amsity tyde.b(mma h.ec0,
ltyp  rLE_ams; h.<
ltyp itch ?; h.+= 1i
(tfin;
   mma LE_am  rltyp[i].otAt);| thLE_ami true!ret" if (!allowe{ bclassBoitkl-!thrn}optclassBod &&AL);
= 8C (sestfC_HANGItpE_amslde.bv$1.ous disePns. i       tslouchdENTu  re "eame"
este.b"reak`/`cs"MEt &duplictor=pion or ls which5)e (sedeon st  default vtrea, 
ons.Duplictorhity$1 mma .n oHexhd  8.pars.creLevd typ) !thde.b(mma h.ec0,
ltyp  raratipE_ams; h.<
ltyp itch ?; h.+= 1i
(tfin;
   mma LE_am  rltyp[i].otAt); (refe (see
  InnerP     thLE_amEMBIND_VAR, 
ons.Duplictorh ? ialis:e.n oHexhnt (); L);
= 8);
  seaCcuVar-seLE_a oseltyp e, xpressionSsEMEt &classBs themrasolonantarray. `close`.  /the  t mas"trueth
};s)) /the s);


Et olon`
ons.Emp  ` 
   buetssBoseGINrobePns.esubaeq)  tCcuVarsttowE
est/ th!nodi  butwemas")emr n
be p 
 triE/ `iali` (whichd  //eede olonde.barray
laultPas).;
ich5)LE_IDode((typtTodefault vclose,tePns.Tut.arseCuVar,tePns.Emp   (ith 'let'."); }
    thity$1 mma eltnMec[],tairsinamu &&de);ssBody.!node.shNoclosei)t{1; i >= 0!airsieinIdment)reak  true;
         "Vari; types$>= 0ePns.Tut.arseCuVarENT)ty to    {Tut.arseCuVareclosei)t{.op"))an
israsentexsi;airsinamaecla;in
optonmma ens{yb(void 0ic=At);| thePns.Emp  s.ec {
    nod return thiscuVari
(t(tfintens{yb typdFUNC_HAcmaVn)
};

pp$t (td return thisellipsihity$1 1 isens{ybif (!LE_IDSp, ("0ith 'let'."); }
    thi; types$>= 0ath 'let'."); }
    th  ==is.opt (td return thiscuVarENT)ath 'let'."); }
    thstut.arseCuVar
< 0iest(ttttt bith 'let'."); }
    thstut.arseCuVar
TomaVerorOf .an
israsentexsi$1 1 isens{ybif (!LE_IDhht = isForIatart with 'let'."); }
    thode());UNC_HAcmts (!curcmtp !th}optclassBocmts L);
ich5)e (seUne.  rv d
  default ve, )ion")mma emerl.ecith.orOf .optmma enr Toith.enr;$1 mma .n o Toith..las.oe);    node.in.eat(type. ==.lastT eleytemem;
(t(thireak   if ucturingErrosrOf te C    { ;
  'yteme'MENT`       thiinunctis geat(type"i.true;
   if (!ineryncE ==.lastT elersion >
(t(thireak   if ucturingErrosrOf te C    { ;
  'rsion'MENT`       thiinunctismentsGod
    { this.rais
    {
   uro/ pT{
 S 'pe(n!inntexsFde, In it ==.lastT elereak`/`cs">
(t(thireak   if ucturingErrosrOf te C    { ;
  'reak`/`cs'di  ct();
fde,  in ii+ " ee"i.true;
   if (!inntexsSrOse Beat(t ==(.lastT elereak`/`cs"eili.lastT elersion >>
(t(thireak   if osrOf te( C    { ;
  " +i.last+ " i  ct();
srOse {in ii+ " lse {
beat("ni.true;
   if (!n this.st = fu.las>>
(t(thireak   if osrOf te( Ustatementen this.r'" +i.last+ "'"ni.true;
   if (!generator = this.eat<yns.etAt); (ref inode) {
  orOf ele)))GexpexOf("\\"od!ret-1e{ bclassBo  }
ceL)reeecmaVerorss Dt?lif (!e.  rv dWis.sSass De:lif (!e.  rv dWis.sde);    ret = fu.las>>t{1; i >= 0!if (!ineryncE ==.lastT elersion >
(t(t(thireak   if ucturingErrosrOf te C    { ;
  n this.r'rsion'MoutunctismentsGod
    { this.raisssreak   if ucturingErrosrOf te( dssSn this.r'" +i.last+ "'d  /e.  rv d")nt (); L);
= 8);
  /the tart  t masENT
n sif (!allo.8Ife`libltPa`.  /t &&thu
  olonwhen pio  re pr 0)
 ies),e=t wilistarom 'grintSn this.s  rtoolonsif (!allos which5)
  no if (
  default vlibltPaety$1 mma .ons.ecmaVer
  no if (= th(s.optquenttartN!!libltPae.optquentClassBody");
  th"Iif (!allowede()>= 0!libltPaety$1 ); elsee (seUne.  rv d(treapde););| thnoING.lastT elersion asElivateN
 thi if (dYi;
(t(tfintreak a thi if (dYi.ecnoINGsrOf "nstarrais
    ifnoINpL);
ich5)LE_IDIif (= th   default vpty$1 
 ! .ons.ecmaVerorOf = th(s.opt)
};

pp$t (td return this.las>ty typeNGING.n o To

pp$ame) O1; Contextual( {
    no!n this.>ty typeNGING.n o To

pp$t (trn this. !e());estTo fix https://gowEubscuV/acornjs/acorn/issues/575e());est`ct();`MEt e`
    { t`|n this.s (!cubnew=ce);
 !  rtoe else ');
 !.e());estBut/thereE  // bcha csito Lop/the ce);
 !  , coven this.rds ce)sk`triE/ 
n sif (!allosouchdENTaopr 0)
   .n o.e());estI, coveprev.ous  t masiseaCdoiEMnode;doe/// ttappRembeca;
  the ce);
 !-managrse  "ctisl, ("y Forored coven this.e););| thhnoING.lastT elext();"eili.oING.lastT ele
    { thi  =on >=dm ty toessBodyEndd!retuy toessBodySrOf .+ 1tility to inodechalC thAtvuy toessBodySrOf od!ret46a == types$ {
  e');
 !.Lop(ode());UNC_HA

pp$t (td turn this.las !thrn(init);
   reak (statement nttarrais
    ifnoINpL);
ich5)LE_IDPrivate if (   default vpty$1 
 ! .ons.ecmaVerorOf = th(s.opt)
};

pp$t (td return thisprivate i>ty typeNGING.n o To

pp$ame) O1; Context);
   reak (statement nttarraisquenttartNe.optquentClassBody");
  th"Private if (!allowis.} elseFe.bv$lidau re xptyp  csue;
   if (!generatoe (sed=ivateFde, sity$1 1     node.privateNlasSrOck itch ?  ret0 == types$ {
  ut.sl !node.handle("Private
fde,  '#" +ihnoING.las)t+ "'dmust/be dect(red  reahLanclosrse  t();"s (bindinontext est(t(t {
  privateNlasSrOck[node.privateNlasSrOck itch ? - 1].u
   (!curtreapde););n
isCa
ssclassBonoINpL);
= 8);
  seytemeNabelssionStinunctigeat(type which5)
  noYteme   default vaorIn i)ion")>= 0!if (!ytemedYiityh (refytemedYi.ecmaVersrOf "nst$1 
 ! .ons.ecmaVerorOf = th(s.optquenttartNe.opt
    {
    nod return thissemisility to   In  rtSon(node, e    ( {
    nod!return thisorOfasElivateNt (trorOf sE;
r)>ty typeNGINGdelegaor
  dtkl-ca1 i aratireak`/`c f  typde);nontext est(tNGINGdelegaor
  node.shNo.parseStorOf.c.tofiaratireak`/`c f if (!LE_IDhht = isForIaorIn i)O1; rais
    ifdy, "ClassBody");
  th"Ytemeode(node, i.pL);
ich5)LE_ID, thin  default vaorIn i)ion")>= 0!if (!a thidYi)intreak a thidYi.ecmaVersrOf "nst$1 
 ! .ons.ecmaVerorOf = th(s.optquenttartNe.optaratireak`/`c f if (!LE_IDhht =Unaryd typesa.un (decl.raaorIn i)O1ptclassBody, "ClassBody");
  th"A thiode(node, i.pL);
mma Lp$4 f );
  ripr to.par);
= 8T{
 tfC_HANGItis  striratrt.slNabceenerat GItpE_slNa   ths It
= 8take/ 
n offse!  rteglo ( rtoe ee  uro/ pe`innod`)iratexpector
= 8the soclse {
e, covea   t, atrOchtstthe menh(eler n
covle))
este, covea   t mnodage,MEt &covntrt.slseaC`Syntax    t`ttowExth
}
estmnodage which4 ut.sltTodefault vpYi,bmnodagepty$1 
 ! ls..ecgetLineInfouty to inod, men)O1ptmnodage.+= "e("t+ ooci'inet+ ":"t+ oocinodumnt+ ")".optmma ere.ecNew=Syntax    t(mnodagep.optereopYi  rLYit.ereols..ecls.t.ereout.sldAc f if (!LYi.optmarow{erepL);
ich4   if ucturingErr  rLch4   if );
ich4  urPenh(eler  default vpty$1 
    {
  generatosoclse {sity$1 1 classBonew=Penh(ele  {
   urLine, if (!LYi - uy toeineSrOf o (); L);
mma Lp$3 f );
  ripr to.par);
mma S 'per  default  S 'pe(ilagspty$1 quentilagsr  dlags;} elseAeltyp e, mma-dect(red .lassesttrhetouro/ pelxptcal=s 'pe$1 quentvE_on([]c=AtlseAeltyp e, lxptcally-dect(red .lassesttrhetouro/ pelxptcal=s 'pe$1 quentlxptcal=n([]c=AtlseAeltyp e, lxptcally-dect(red ting it Dect(rlse {
.lassesttrhetouro/ pelxptcal=s 'pe$1 quentfC_HANGI sn([]c=AtlseAeehis.tyto disePns.ethetsif (!allosrefere csi'reak`/`cs'
); (ref intexsFde, In it  dtkl-ca});
= 8T{etfC_HANGIsesttrhis ooduleen epetutentkeydect(red v$1.gErrsesttrhetouro/ pes 'petsttis. {eco detars
duplictor=v$1.gErr
.lass which3ee)  {S 'pen  default valagspty$1 quents 'peSrOck (!curtew=S 'pe(ilagspnt L);
ich3eexitS 'per  default vpty$1 quents 'peSrOck (op(ode});
= 8T{etstem says:
= 8> At/the  tpelxvelsStaINdefault ,  t atempt, default  dect(rlse {o;

e
= 8> treLev.rt)keevE_odect(rlse {o;rlsh {ecoa{
t)keelxptcal=dect(rlse {o.
ich3etreLeting it sAsVarInS 'per  default vs 'pepty$1 Accessovs 'petilagsr& SCOPE_FUNCTIONe    }.finiinModulee ==(s 'petilagsr& SCOPE_TOP) L);
ich3edect(reNlastTodefault v.las,bbexpectT (t, men)ty$1 
 ! redect(red   dtkl-ca1 
   bexpectT (td retBIND_LEXICAcat{1; i mma e 'per   {
   uro/ pS 'pe(nt 1 1 cldect(red   s 'petlxptcalGexpexOf(.las)t> -1tilis 'petiing it sGexpexOf(.las)t> -1tilis 'petmmaGexpexOf(.las)t> -1t 1 1 s 'petlxptcalG(!curtlas)de););| th.finiinModulee ==(s 'petilagsr& SCOPE_TOP);
(t(tfintdelete reak (sdefintrodee'"s[tlas]ensAsVae clas
   bexpectT (td retBIND_SIMPLE_CATCHat{1; i mma e 'petion(maVer uro/ pS 'pe(nt 1 1 e 'petitlxptcalG(!curtlas)de);ae clas
   bexpectT (td retBIND_FUNCTIONe {1; i mma e 'pet2on(maVer uro/ pS 'pe(nt 1 1 
    {
   reLeting it sAsVar;
(t(tfintcldect(red   s 'pe$2tlxptcalGexpexOf(.las)t> -1waitAt);cmaVersiofintcldect(red   s 'pe$2tlxptcalGexpexOf(.las)t> -1tilis 'pe$2tmmaGexpexOf(.las)t> -1taitAt);s 'pe$2tiing it sG(!curtlas)de);ae clas{1; i de.b(mma h.ecquents 'peSrOck itch ? - 1; h.>ec0O --i == types$1.a e 'pet3.ecquents 'peSrOck[i].otypes$| ths 'pet3tlxptcalGexpexOf(.las)t> -1tsEli(hs 'pet3tilagsr& SCOPE_SIMPLE_CATCHatsEls 'pet3tlxptcal[0]d ret.las)t||otypes$$$$$! {
   reLeting it sAsVarInS 'pehs 'pet3atsEls 'pet3tiing it sGexpexOf(.las)t> -1ision >=dmencldect(red   e && !thindi .op"))
raindin
raindis 'pet3tmmaG(!curtlas)de);););| th.finiinModulee ==(s 'pet3tilagsr& SCOPE_TOP);
(t(tfifintdelete reak (sdefintrodee'"s[tlas]ensAsVpes$| ths 'pet3tilagsr& SCOPE_VAR)t{.op"))an
isras
(t}a1     cldect(red)int scoput.slucturingErropYi,b("Iif (!allor'" +i.last+ "'dhENTal, ("y bemasdect(red"ni.truL);
ich3ee (seeocllodee'"   iefault midsion")= 8s 'petiing it sdmust/be emp   ENTModulee "ctiisealwaysClass D.ue;
    {
  s 'peSrOck[0]tlxptcalGexpexOf(idi.lasod ret-1tsEest(t(t {
  s 'peSrOck[0]tmmaGexpexOf(idi.lasod ret-1)t);
   reak (sdefintrodee'"s[idi.las].ecidt (); L);
ich3eeuro/ pS 'per  default vpty$1 classBody, "s 'peSrOck[quents 'peSrOck itch ? - 1] L);
ich3eeuro/ pVarS 'per  default vpty$1 de.b(mma h.ecquents 'peSrOck itch ? - 1;; h--at{1; i mma e 'per   {
  s 'peSrOck[i].otype| ths 'petilagsr& SCOPE_VAR)t{.classBoe 'peritAt; L);
lsedeuld be  stfulsde.b` {
 `}
`new.target`}
`suplo e`}
`suploepr 0)
  `,MEt &`suplo[pr 0)
  ]`.
ich3eeuro/ pT{
 S 'per  default vpty$1 de.b(mma h.ecquents 'peSrOck itch ? - 1;; h--at{1; i mma e 'per   {
  s 'peSrOck[i].otype| ths 'petilagsr& SCOPE_VARtsEli(s 'petilagsr& SCOPE_ARROWi)t{.classBoe 'peritAt; L);
mma = th   default  ody")LE_  r, men,cls.pty$1 quentt (td t"".optquentemerl.ec)Yi.optmaVerenr To0ca1 
   LE_  r generatosoclse {si
fifintquentls..ectew=SourceLoclse {)LE_  r, ls.p.true;
   LE_  r generatodiowSuSourceFilf)
(t(thireak sourceFilf  rLE_  r generatodiowSuSourceFilf.true;
   LE_  r generatoranges>
(t(thireak   ngesn([men,c0]c.stL);
lseSrOf .an ASTc;
  thatrOch!nod
 emerl.offse!.;
mma Lp$2 f );
  ripr to.par);
Lp$2rorOf = thr  default vpty$1 classBotew=ody")reaktemaVerorOf temaVerorOf is.i L);
ich2rorOf = thAptTodefault vpen,cls.pty$1 classBotew=ody")reaktepen,cls.ptL);
lseFlassB.an ASTc;
  thadpect
`.par`MEt e`enr` pr 0)
 ies.;
default  ClassBody"Atv;
  tha (t, men,cls.pty$1 aratit (td turn .optaratienr To)Yi.opt
    {
  generatosoclse {si
(t(thiNGINGoocienr Tols.t.rue;
   if (!generatoranges>
(t(thiNGINGrange[1]  rLYit.rais
    ifnoINpL;
ich2rClassBody"t  default vtrea, urn pty$1 classBoClassBody"AtGtve )reakte;
  tha (t, ty toessBodyEnd, ty toessBodyEndLs.ptL);
lseFlassB..ons.atxgiven penh(ele;
ich2rClassBody"AptTodefault v;
  tha (t, men,cls.pty$1 classBoClassBody"AtGtve )reakte;
  tha (t, pen,cls.ptL);
ich2r 'pyody"tTodefault v;
  pty$1 
 ! .ewody"tTotew=ody")reakte!node.handlemaVerorOf is.i !thde.b(mma ircpsiifnoINisi;aewody"[pr 0].ecnoIN[pr 0]t.rais
    ifnewody"e});
= 8T{
 tfilem 'gaains Uni "ctipr 0)
 ies;extlse  dt`in` the ECMAStemptrstem!alclse {.
= 8T{etltypo;

e;extlse  dtt)keeso:
= 8$$('#tgErr-bexary-uni "ct-pr 0)
 ies;>tfiguee > tgErr
> tbodyt> trt> td:nth-ch!ld(1)t "ct').map(el =>e c.;nnerText);
= 8#tgErr-bexary-uni "ct-pr 0)
 iesnd ==ecma9BexaryPr 0)
 ies;f "ASCII ASCII_Hex_Digit AHex Alphabese {Alpha Any  isFor dtBidi_de);roltBidi_dtBidi_Mi   t dtBidi_M Case_IororgErr
CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dexhd);tions_IororgErr_C th_Poi`c
DId);precLev.r);p Diatemse {Dia Emoji Emoji_C mpon/ peEmoji_Mod!allorEmoji_Mod!allo_BtypeEmoji_Pe.  ntlse {
ExtenrlorExt Grapheme_BtypeGr_BtypeGrapheme_ExtenreGr_Ext Hex_Digit Hex IDS_Bexary_Opt(type.IDSB IDS_Trexary_Opt(type.IDST.ID_de);inue.IDC.ID_SrOf .IDS Iifographe {Iifo Joi`_de);roltJoi`_d Logtcal_Os. {_Exceenera LOE Lowercase Lower Ma ? Nonchalse   _C th_Poi`c
NChar P     t_Syntax P  _Syn P     t_White_Space P  _WS Quotlse {_Mark QMark Radtcal=Rege {al_Ixpectope.RI Se)  nce_T  `!nLl ST  `=Soft_DotttriSD T  `!nLl_Pefauulse {
T  `=Unialld_Iifograph UIifo Uppercase Upper V$1.gse {_Selecope.VS White_Space space XID_de);inue.XIDC.XID_SrOf .XIDS".od ==ecma10BexaryPr 0)
 ies;f ecma9BexaryPr 0)
 ies;+ " Extenrld_Ps Dographe ".od ==ecma11BexaryPr 0)
 ies;f ecma10BexaryPr 0)
 ies.od ==ecma12BexaryPr 0)
 ies;f ecma11BexaryPr 0)
 ies;+ " EBtypeEC mp EMod EPe.  ExtPs D".od ==ecma13BexaryPr 0)
 ies;f ecma12BexaryPr 0)
 ies.od ==ecma14BexaryPr 0)
 ies;f ecma13BexaryPr 0)
 ies);
mma uni "ctBexaryPr 0)
 ies;f y$1 9: ecma9BexaryPr 0)
 ieseon 10: ecma10BexaryPr 0)
 ieseon 11: ecma11BexaryPr 0)
 ieseon 12: ecma12BexaryPr 0)
 ieseon 13: ecma13BexaryPr 0)
 ieseon 14:=ecma14BexaryPr 0)
 iese});
= 8#tgErr-bexary-uni "ct-pr 0)
 ies-of-s { resod ==ecma14BexaryPr 0)
 iesOfS { res;f "Btyic_Emoji Emoji_Keycap_&eq)  cs RGI_Emoji_Mod!allo_&eq)  cs RGI_Emoji_Flag_&eq)  cs RGI_Emoji_Tag_&eq)  cs RGI_Emoji_ZWJ_&eq)  cs RGI_Emoji");
mma uni "ctBexaryPr 0)
 iesOfS { res;f y$1 9: ""eon 10: ""eon 11: ""eon 12: ""eon 13: ""eon 14:=ecma14BexaryPr 0)
 iesOfS { rese});
= 8#tgErr-uni "ct-geat(tl-cLevgory-ame) s
mma uni "ct.eat(tlCLevgoryVme) s;f "Cased_Ls.  {
LC Close_Pefauulse {
Peede)necope_Pefauulse {
Pc de);roltCc c);rltCuro/ cy_SymboltSc Dexh_Pefauulse {
P.r);cimLl_Numb {
Nd digit Enclosrse_Mark MeeFlaLl_Pefauulse {
PfeFe.matxCf8In ii+ _Pefauulse {
Pi Ls.  {
L Ls.  {_Numb {
Nl Line_&eLE_a pe.Zl Lowercase_Ls.  {
Ll Mark M dembexrse_Mark Ma ?_SymboltSm Mod!allo_Ls.  {
Lm Mod!allo_SymboltSk Nonspacrse_Mark M  oumb {
N Optn_Pefauulse {
Ps Osh {eC Osh {_Ls.  {
Lo Osh {_oumb {
No Osh {_Pefauulse {
Po Osh {_SymboltSo );
agraph_&eLE_a pe.Zp Private_Useede Pefauulse {
P pefau &eLE_a pe.Z Space_&eLE_a pe.Zs Spacrse_Mark Mc Suroogaor
Cs SymboltS Titlecase_Ls.  {
Lt=UnaisFor dtCn Uppercase_Ls.  {
Lu");
= 8#tgErr-uni "ct-atempt-ame) s
mma ecma9StemptVme) s;f "Adlam Adlm Ahn` Ana plian_Hllooglyphs Hluw ArgEe {ArgE{Armenian Armn AveorOn Avst BaeineseeBaeieBamumeBamueBassa_VaheBasseBatakeBatkeBengaeieBeng BhaiksukieBhkseBopomofoeBopo Brahmi Brah Brailrr
Brai BugineseeBugieBuhideBuhdtCanadtan_Aborigi`Ll Cans Carian Cari Caucastan_Albanian Aghb Chakma Cakm Cham Cham Chlookee Chlo demm {
Zyyy depse {deps Qaa {duneide.m Xsux CypriotxCpf .Cyrilre {dyrltD.  rec
Dsf .Devanagari Deva Duployan Dupl Egypsean_Hllooglyphs Egyp Elbasan Elba EmaVope {EmaV Georgian Geor Glagplise {Glag G th!c G theGranthaeGraneGreekeGrekeGuj(rlseeGujr GurmukaV Guru HaneHanieHanguleHangeHanunooeHanoeHatraneHatrtHebrew=Hebr Hi
agana Hi
a Imperi+ _Argmae {Armi InhloittriZinh Qaai Inatempte {al_Pahlavi Phli Inatempte {al_Parth!aneP
 i JavaneseeJava KaimaV KmaV Kannada Knda Katakana Kana Kayah_LV Kali KharoshmaV Khar Khmer Khmr Khojki Khoj Khudawadt SexpeLaoeLaooeLa;ineLa;neLepchaeLepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lyc!aneLyc!eLyd!aneLydt MahajanieMahjeMalayalam Mlym Mandae {Mand{ManichaeaneManieMarcovntMarctMasE_am_Goxpe G nm Meetei_MayekeMtei Menrl_Kikakui Menr Meroise _CursiveiMerc Meroise _Hllooglyphs Mero MiaoePlrd Mod! Mongplian Mong Mro MrooeMonsanieMons Myanmar Mymr NabataeaneNbat8New_Tai_Lue.Tme)8Newa8Newa8Nko8Nkoo8Nush)8Nsh)8Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Itare {Itar Old_Norrh_ArgEeaneNarb Old_P  `!c P  ` Old_P  stan Xpfo Old_Sourh_ArgEeaneSarb Old_Turk!c Orkh Oriya Orya Odage.Osge.Osmanya Odma Pahawh_Hmong Hmng Palmyo/ e Palm Pau_Ci`_Hau Pauc Phags_Pa Phag Phoenic!anePhnx Psal  {_Pahlavi Phlp=RejangeRjngeRuni eRunreSamaritaneSamreSaurexhtraeSaur Shalsda Shrd ShaveaneShaw Seddham Sedd SegnWemsengeSgnw Senhala SenhtSora_SompengeSoraeSoyemboeSoye SundaneseeSund Syloti_Nagri Sylo Syriac Syrc.Tmgaeog Tglg.Tmgbanwa8Tmgb Tai_Le.Tmee Tai_Tham Lana Tai_Viec
Tavc
Takri Takr Tamil Taml Tangut Tang
T lugu
T lu Thaana Thaa Thai Thai TibetaneTibt T!alnagh Tfng
Tirhuta
Tirh Ugarise {Ugar V$i V$ii Warang_Citi Wara Yi Yiii Zanabazar_Squ

e;Zanb".od ==ecma10StemptVme) s;f ecma9StemptVme) s;+ " Dogra Dogr Gunjala_Goxpe G ngeHan!al_Roh!noya Rohg Makasar Maka Medefaid{ r Medf Old_Sogd!aneSogoeSogd!aneSogd".od ==ecma11StemptVme) s;f ecma10StemptVme) s;+ " Elymae {ElymeNaxpecagari Naxp Nyiakeng_Peachue_Hmong Hmnp Wancho Wcho".od ==ecma12StemptVme) s;f ecma11StemptVme) s;+ " Chorasmian Chrs{Diak{Diveo_Akuru Khitan_SmLll_StemptrKico;Yezi;Yezidi".od ==ecma13StemptVme) s;f ecma12StemptVme) s;+ " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa
Tnsa
Toto Vimakuqi Vima".od ==ecma14StemptVme) s;f ecma13StemptVme) s;+ " Hrkt Katakana_Or_Hi
agana Kawi Nae_Mundari Nag`=Unknow{
Zzzz");
mma uni "ctStemptVme) s;f y$1 9: ecma9StemptVme) seon 10: ecma10StemptVme) seon 11: ecma11StemptVme) seon 12: ecma12StemptVme) seon 13: ecma13StemptVme) seon 14:=ecma14StemptVme) s L);
mma da aon({};nNC_HANGINbuildUni "ctDa a(r = this.eapty$1 
 ! r Toda a[r = this.ea] 
e est(tbexary:et  //Regexp(uni "ctBexaryPr 0)
 ies[r = this.ea] + " " +iuni "ct.eat(tlCLevgoryVme) s.eon >=bexaryOfS { res:et  //Regexp(uni "ctBexaryPr 0)
 iesOfS { res[r = this.ea].eon >=nonBexary:eion >=dm.eat(tl_CLevgory:et  //Regexp(uni "ct.eat(tlCLevgoryVme) s.eon >=  Stempt:et  //Regexp(uni "ctStemptVme) s[r = this.ea].
isras
(t} !thd.nonBexary.Stempt_ExtenionSs f d.nonBexary.Stempts.} ed.nonBexary.gc f d.nonBexary..eat(tl_CLevgory !thd.nonBexary.sc f d.nonBexary.Stempts.thd.nonBexary.scx f d.nonBexary.Stempt_ExtenionSs;pL;
de.b(mma h.ec0,
ltyp  r[9, 10, 11, 12, 13, 14]; h.<
ltyp itch ?; h.+= 1ity$1 mma e = this.eat rltyp[i].otAtbuildUni "ctDa a(r = this.eap;pL;
mma Lp$1 f );
  ripr to.par);
mma RegExpV$lidau onSrOsh   default  RegExpV$lidau onSrOsh LE_  rpty$1 quentLE_  r  rLE_  r.optmaVerv$lidFlagsr  "gim" +ihLE_  r generator = this.eat(tyns? "uyi : "") +ihLE_  r generator = this.eat(ty9s? "si : "") +ihLE_  r generator = this.eat(ty13s? "di : "") +ihLE_  r generator = this.eat(ty15s? "vi : "").optmaVeruni "ctPr 0)
 ies;f da a[LE_  r generator = this.eat(ty14s? 14s:rLE_  r generator = this.ea].optquenteourced t"".optquentilagsr  "".optquentemerl.ec0O1; maVerehis.tU   dtkl-ca1 maVerehis.tV   dtkl-ca1 maVerehis.tN   dtkl-ca1 maVerpYi.ec0O1; maVeressBIntVme) 
  0O1; maVeressBS { reVme) 
  "".optquentessBAs  rt.eaIsQua (!algErr  rdtkl-ca1 maVernumCap"); }
P
// s
  0O1; maVermaxBackRefere csi  0O1; maVergroupNlasslf []););quentbackRefere csNlasslf []);L);
RegExpV$lidau onSrOshipr to.par!e.  ptTodefault  e.  ptosrOf tep     t (alagspty$1 mma uni "ctSetsr  dlagsGexpexOf("v"od!ret-1;$1 mma uni "ctr  dlagsGexpexOf("u"od!ret-1;$1 quentemerl.ecemerl.|c0O1; maVereourced tp     t + "".optquentilagsr  dlags;} e| thuni "ctSetsr ==is.opLE_  r generator = this.eat(ty15)t);
   reak ehis.tU   u && !thin {
  ehis.tV   u && !thin {
  ehis.tN   u && !thContext);
   reak ehis.tU   uni "ctr ==is.opLE_  r generator = this.eat(ty6 !thin {
  ehis.tV   itkl-ca1 i maVerehis.tN   uni "ctr ==is.opLE_  r generator = this.eat(ty9t (); L);
RegExpV$lidau onSrOshipr to.par!et.sltTodefault trt.slN(mnodagepty$1 is.opLE_  r   if ucturingErro scopsrOf te("Inameidxregulma ede(node, : /" +ihmaVereource)t+ "/: " +imnodagepode});
= 8If uedlagtisxgivenEMnode;classBs thee "ctipoi`c
at/the expex (itCcuVbinesd
 euroogaor
pair).
= 8Osh {wiis.puode;classBs thee "ctiun ite, coveexpex (
   buearLE_tsStaINeuroogaor
pair).
RegExpV$lidau onSrOshipr to.par!aptTodefault  apt(iraaorceUity$1 1     aaorceU Tretvoid 0 )oaorceU Toitkl-ca
in
 ! i.ecmaVersource;$1 mma l=n(s itch ?;} e| thh.>ecaety$1 );
    if-1
isrue;1._cc=n(s chalC thAtviede()>= 0!(aorceU ility toehis.tUe    c <  0xD7FF    c >ec0xE000.ilii.+ 1t>ecaety$1 );
    ifc
isrue;1._ctart n(s chalC thAtvi.+ 1)O1ptclassBotart >ec0xDC00. ==.art <  0xDFFF ? (
 << 10)t+ .art - 0x35FDC00.:fc
L);
RegExpV$lidau onSrOshipr to.par!.artIxpex Todefault  .artIxpex (iraaorceUity$1 1     aaorceU Tretvoid 0 )oaorceU Toitkl-ca
in
 ! i.ecmaVersource;$1 mma l=n(s itch ?;} e| thh.>ecaety$1 );
    ifl
isrue;1._cc=n(s chalC thAtvie, .artde()>= 0!(aorceU ility toehis.tUe    c <  0xD7FF    c >ec0xE000.ilii.+ 1t>ecat||otypes$(tart n(s chalC thAtvi.+ 1))
< 0xDC00.ili.art > 0xDFFFety$1 );
    ifi.+ 1
; rais
    ifi.+ 2
L);
RegExpV$lidau onSrOshipr to.par!ouro/ peTodefault  ouro/ pe(aorceUity$1 1     aaorceU Tretvoid 0 )oaorceU Toitkl-ca
inclassBody, "at ty topYithaorceUi
L);
RegExpV$lidau onSrOshipr to.par!lookaheae   default  lookaheae (aorceUity$1 1     aaorceU Tretvoid 0 )oaorceU Toitkl-ca
inclassBody, "at ty to.artIxpex ty topYithaorceUithaorceUi
L);
RegExpV$lidau onSrOshipr to.par!adva csi  default  adva csi(aorceUity$1 1     aaorceU Tretvoid 0 )oaorceU Toitkl-ca
inmaVerpYi.ecty to.artIxpex ty topYithaorceUi);L);
RegExpV$lidau onSrOshipr to.par!eaptTodefault  eapt(chraaorceUity$1 1     aaorceU Tretvoid 0 )oaorceU Toitkl-ca
in
    {
   uro/ p(aorceUitTretch)t);
   reak adva cs(aorceUi);1 );
    ifd &&A; rais
    ifitkl-!L);
RegExpV$lidau onSrOshipr to.par!eapCharstTodefault  eapCharst(chsraaorceUity$1 1     aaorceU Tretvoid 0 )oaorceU Toitkl-ca
in
 ! pYi.ecty to)Yi.optde.b(mma h.ec0,
ltyp  rchs; h.<
ltyp itch ?; h.+= 1ity$1 e;1._cch  rltyp[i].otAt););1._ccurr/`c f if (!at pYithaorceUi);1 1     curr/`c fret-1t   curr/`c !retch)t);
   is
    ifitkl-!indin
rainpYi.ecty to.artIxpex pYithaorceUi);1 }
inmaVerpYi.ecpYi.optclassBod &&AL);
=**
 * V$lidaue thetflagsrLE_tsStaINgiven RegExpLaultPa.
 *
 * @LE_am {RegExpV$lidau onSrOsh}
srOse8T{etsrOse8 n
mmlidaue RegExp.
 * @classBs {void}
i*/
ich1.mmlidaueRegExpFlagsr  default vsttor)t{1; 1._cv$lidFlagsr  sttorrv$lidFlags;$1 mma flagsr  sttorrdlags;}$1 mma u   itkl-ca1 1._cv Toitkl-ca
inde.b(mma h.ec0; h.<
dlagsGitch ?; h++ity$1 e;1._cdlagt  dlagsGchalAtviede()1     v$lidFlagsGexpexOf(dlagod ret-1)t);
   s$ {
  ut.sl sttorrsrOf te Inameidxregulma ede(node,  dlagme(bindin
ison    flagsGexpexOf(dlag,fi.+ 1)t> -1ision >=dm {
  ut.sl sttorrsrOf te Duplictorxregulma ede(node,  dlagme(bindin
ison    flagtT eleuwe{ bu   u && in
ison    flagtT elevwe{ bv   u && in
isn
HAat inode.generator = this.eat(ty15ENT)uENT)v)t);
   reak ut.sl sttorrsrOf te Inameidxregulma ede(node,  dlagme(bin}AL);
=**
 * V$lidaue thetp     t LE_tsStaINgiven RegExpLaultPa.
 *
 * @LE_am {RegExpV$lidau onSrOsh}
srOse8T{etsrOse8 n
mmlidaue RegExp.
 * @classBs {void}
i*/
ich1.mmlidaueRegExpP     t   default vsttor)t{1; reak uegexp_p     tvsttor)s.} elseT{etgoal=symboltde.bcovepE_stiise|P     t[~U, ~N]|.tI, cove(noons of} elsepio  re  'gaains a |GroupNlas| witpE_stitowExthetgoal=symbol} else|P     t[~U, +N]|MEt e;
  th  /e. ons insteae.eT{row{a *Syntax    t*} elseabceeneraAat _P_ didx/ tt 'gde.m  n
covlg_ammae,titaIny xlingCossSta_P_} elsewe);// ttmas.ted bybcovepE_st,  t itaIny Early E   t coxpe it sdxptyp.ue;
   !sttorrshis.tN ntaif (!generator = this.eat(ty9t ==sttorrgroupNlass itch ? >t0 == typesttorrshis.tN   u && !thin {
  uegexp_p     tvsttor)s.At; L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-P     t
ich1.uegexp_p     t   default vsttor)t{1; sttorrpYi.ec0O1; sttorressBIntVme) 
  0O1; sttorressBS { reVme) 
  "".optsttorressBAs  rt.eaIsQua (!algErr  rdtkl-ca1 sttorrnumCap"); }
P
// s
  0O1; sttorrmaxBackRefere csi  0O1; sttorrgroupNlass itch ?   0O1; sttorrbackRefere csNlass itch ?   0O11; reak uegexp_disjefault vsttor)ca
in
   sttorrpYi.!retsttorrsource itch ? == typelseMake thetslastmnodages ENTV8.= 9 || thsttorrshNo0x29 /* )o*/a == types$sttorrut.sl "Unmas.ted ')'me(bindin
ison    sttorrshNo0x5D /* ]o*/atilisttorrshNo0x7D /* }o*/a == types$sttorrut.sl "L teaqua (!aler .typketsme(bindin
is}
in
   sttorrmaxBackRefere csi> sttorrnumCap"); }
P
// s == typesttorrut.sl "Inameidxescape"i);1 }
inde.b(mma h.ec0,
ltyp  rsttorrbackRefere csNlass; h.<
ltyp itch ?; h.+= 1ity$1 e;1._c.n o Toltyp[i].otAt);| thsttorrgroupNlass expexOf(.las)t ret-1)t);
   s$sttorrut.sl "Inameidx.lasd cap");esrefere csdme(bindin
is}
L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-Disjefault 
ich1.uegexp_disjefault    default vsttor)t{1; reak uegexp_al  {natevevsttor)s.AtssBody.sttorrshNo0x7C /* |o*/a == typereak uegexp_al  {natevevsttor)s.At}.} elseMake thetslastmnodage ENTV8.= 9at inode.uegexp_shNQua (!alervsttor,tuhis. == typesttorrut.sl "N th!nodratrepeLe"i);1 }
in    sttorrshNo0x7B /* {o*/a == typesttorrut.sl "L teaqua (!aler .typketsme(bin}
L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-Al  {nateve
ich1.uegexp_al  {nateve   default vsttor)t{1; ssBody.sttorrpYi.<tsttorrsource itch ? ntaif (!uegexp_shNT  `vsttor)>
(t(thi}
L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-T  `
ich1.uegexp_shNT  `   default vsttor)t{1; at inode.uegexp_shNAs  rt.eavsttor)>== typelseHEt ody`Qua (!algErrAs  rt.ea Qua (!aler` al  {nateve.e());est`sttorressBAs  rt.eaIsQua (!algErr`.  /t &&t , coveessB eapen As  rt.eae());estiseaCQua (!algErrAs  rt.ea.= 9 || thsttorressBAs  rt.eaIsQua (!algErr ntaif (!uegexp_shNQua (!alervsttora == types$lseMake thetslastmnodage ENTV8.= 9 9 || thsttorrehis.tUe = types$s$sttorrut.sl "Inameidxqua (!aler")de);););itAt);UNC_HA
    ifd &&A; ra
 || thsttorrehis.tUt?lif (!e.gexp_shNAnctdsttor)t:lif (!e.gexp_shNExtenrldAnctdsttor) == typereak uegexp_shNQua (!alervsttora);1 );
    ifd &&A; raais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-As  rt.eaeich1.uegexp_shNAs  rt.ea   default vsttor)t{1; 1._cemerl.ecemeorrpYi.optsttorressBAs  rt.eaIsQua (!algErr  rdtkl-ca} else^, $
in    sttorrshNo0x5E /* ^o*/atilisttorrshNo0x24 /* $o*/a == type
    ifd &&A; raaislse\b \B
in    sttorrshNo0x5C /* \o*/a == type    sttorrshNo0x42 /* Bo*/atilisttorrshNo0x62 /* bo*/a == types$
    ifd &&A; );UNC_HAsttorrpYi.ecsrOf .optraaislseLookaheae seLookbeh!nd
in    sttorrshNo0x28 /* (o*/at ==sttorrshNo0x3F /* ?o*/a == type
 ! lsokbeh!nd   itkl-ca1 i at inode.generator = this.eat(ty9 == types$lsokbeh!nd   sttorrshNo0x3C /* <o*/a(bindin
ison    sttorrshNo0x3D /* =o*/atilisttorrshNo0x21 /* !o*/a == types$reak uegexp_disjefault vsttor)ca 9 9 || th!sttorrshNo0x29 /* )o*/a == types$s$sttorrut.sl "Unt  `!nLttrigroup")de);););itAt);ptsttorressBAs  rt.eaIsQua (!algErr  r!lsokbeh!nd; types$
    ifd &&A; );UNC_raaissttorrpYi.ecsrOf .opt
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-Qua (!alereich1.uegexp_shNQua (!aler   default vsttorte!nE   t)t{1; at ie!nE   t Tretvoid 0 )o!nE   t Toitkl-ca
in
    {
  uegexp_shNQua (!alerPrefixvsttorte!nE   t) == typesttorrshNo0x3F /* ?o*/a);1 );
    ifd &&A; rais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-Qua (!alerPrefixeich1.uegexp_shNQua (!alerPrefix   default vsttorte!nE   t)t{1; Accessov typesttorrshNo0x2A /* *o*/atil typesttorrshNo0x2B /* +o*/atil typesttorrshNo0x3F /* ?o*/atil type {
  uegexp_shNBt(tydQua (!alervsttor,t!nE   t) tyi
L);ich1.uegexp_shNBt(tydQua (!aler   default vsttorte!nE   t)t{1; 1._cemerl.ecemeorrpYi.opt    sttorrshNo0x7B /* {o*/a == type1._c`!n.ec0,
max = -1t 1 1 
    {
  uegexp_shN);cimLlDigitsvsttora == types$`!n.ecsttorressBIntVme) ca 9 9 || thsttorrshNo0x2C /* ,o*/at == {
  uegexp_shN);cimLlDigitsvsttora == types$ 
max = sttorressBIntVme) ca 9 9 |}a 9 9 || thsttorrshNo0x7D /* }o*/a == types$HAlseSyntax    tsiifhttps://wwwor = - rternate {al.org/r = -262/8.0/#sec-t  ` types$HA| thmax !ret-1tsE
max <$`!n.sEli!nE   t)t{1; types$s$sttorrut.sl "numb {sMoutsStais. {e!n.{}xqua (!aler")de););); |}a 9 9 |s$
    ifd &&A; ););itAt);UNC_HA| thsttorrehis.tUtsEli!nE   t)t{1; typesttorrut.sl "Incoielete qua (!aler")de););UNC_HAsttorrpYi.ecsrOf .optrais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-Ancteich1.uegexp_shNAnct   default vsttor)t{1; Accessov type {
  uegexp_shNP     tChalse   svsttoratil typesttorrshNo0x2E /* .o*/atil type {
  uegexp_shNRev {seSoeidusAnctEscapevsttoratil type {
  uegexp_shNChalse   ntexsvsttoratil type {
  uegexp_shNUncap"); }
Groupvsttoratil type {
  uegexp_shNCap"); }
Groupvsttora tyi
L);ich1.uegexp_shNRev {seSoeidusAnctEscape   default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt    sttorrshNo0x5C /* \o*/a == type    if (!e.gexp_shNAnctEscapevsttora == types$
    ifd &&A; );UNC_HAsttorrpYi.ecsrOf .optrais
    ifitkl-!L);ich1.uegexp_shNUncap"); }
Group   default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt    sttorrshNo0x28 /* (o*/a == type    sttorrshNo0x3F /* ?o*/at ==sttorrshNo0x3A /* :o*/a == types$reak uegexp_disjefault vsttor)ca 9 9 || thsttorrshNo0x29 /* )o*/a == types$s$
    ifd &&A; ););itAt);s$sttorrut.sl "Unt  `!nLttrigroup")de););UNC_HAsttorrpYi.ecsrOf .optrais
    ifitkl-!L);ich1.uegexp_shNCap"); }
Group   default vsttor)t{1;     sttorrshNo0x28 /* (o*/a == type    node.generator = this.eat(ty9 == types$reak uegexp_groupStem!alervsttora);1 );ae clas
   sttorr uro/ p()t ret0x3F /* ?o*/at);
   s$sttorrut.sl "Inameidxgroup")de););UNC_HAreak uegexp_disjefault vsttor)ca 9 9| thsttorrshNo0x29 /* )o*/a == types$sttorrnumCap"); }
P
// s
+= 1; types$
    ifd &&A; );UNC_s$sttorrut.sl "Unt  `!nLttrigroup")de);rais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-ExtenrldAnct;ich1.uegexp_shNExtenrldAnct   default vsttor)t{1; Accessov typesttorrshNo0x2E /* .o*/atil type {
  uegexp_shNRev {seSoeidusAnctEscapevsttoratil type {
  uegexp_shNChalse   ntexsvsttoratil type {
  uegexp_shNUncap"); }
Groupvsttoratil type {
  uegexp_shNCap"); }
Groupvsttoratil type {
  uegexp_shNInameidBt(tydQua (!alervsttoratil type {
  uegexp_shNExtenrldP     tChalse   vsttora tyi
L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-InameidBt(tydQua (!aler;ich1.uegexp_shNInameidBt(tydQua (!aler   default vsttor)t{1; at inode.uegexp_shNBt(tydQua (!alervsttor,tuhis. == typesttorrut.sl "N th!nodratrepeLe"i);1 }
in
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-SyntaxChalse   ;ich1.uegexp_shNSyntaxChalse      default vsttor)t{1; 1._cch  rsttorr uro/ p().opt    isSyntaxChalse   (ch. == typesttorressBIntVme) 
  ch; typesttorradva cs(a);1 );
    ifd &&A; rais
    ifitkl-!L);fC_HANGItisSyntaxChalse   (ch.t{1; Accessov typec?  ret0x24 /* $o*/til typec? >ec0x28 /* (o*/t ==c? <  0x2B /* +o*/til typec?  ret0x2E /* .o*/til typec?  ret0x3F /* ?o*/til typec? >ec0x5B /* [o*/t ==c? <  0x5E /* ^o*/til typec? >ec0x7B /* {o*/t ==c? <  0x7D /* }o*/ tyi
L;
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-P     tChalse   ;estBut/eapteager.;ich1.uegexp_shNP     tChalse   s   default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt1._cch  r0s.AtssBody.(ch  rsttorr uro/ p()) !ret-1tsE
!isSyntaxChalse   (ch. == typesttorradva cs(a);1 rais
    ifsttorrpYi.!retsttrt!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-ExtenrldP     tChalse   ;ich1.uegexp_shNExtenrldP     tChalse      default vsttor)t{1; 1._cch  rsttorr uro/ p().opt     typec? !ret-1tsEest(tc? !ret0x24 /* $o*/tsEest(t!(c? >ec0x28 /* (o*/t ==c? <  0x2B /* +o*/)tsEest(tc? !ret0x2E /* .o*/tsEest(tc? !ret0x3F /* ?o*/tsEest(tc? !ret0x5B /* [o*/t =est(tc? !ret0x5E /* ^o*/t =est(tc? !ret0x7C /* |o*/ tyi== typesttorradva cs(a);1 );
    ifd &&A; rais
    ifitkl-!L);
lseGroupStem!aler ::
= 8  [emp  ]
= 8  `?` GroupNlas;ich1.uegexp_groupStem!aler   default vsttor)t{1;     sttorrshNo0x3F /* ?o*/a == typeat inode.uegexp_shNGroupNlasvsttora == types$| thsttorrgroupNlass expexOf(sttorressBS { reVme) od!ret-1e{  types$s$sttorrut.sl "Duplictorxcap");esgroupx.las")de);););itAt);ptsttorrgroupNlass (!cursttorressBS { reVme) o; types$
    iA; );UNC_s$sttorrut.sl "Inameidxgroup")de);}!L);
lseGroupNlast::
= 8  `<` RegExpIif (!alloNlast`>`
= 8N te:lif ( updauest`sttorressBS { reVme) `opr 0)
   towExtheteapen .n o.eich1.uegexp_shNGroupNlast  default vsttor)t{1; sttorressBS { reVme) 
  "".opt    sttorrshNo0x3C /* <o*/a == typeat inode.uegexp_shNRegExpIif (!alloNlasvsttor)t ==sttorrshNo0x3E /* >o*/a == types$
    ifd &&A; );UNC_HAsttorrut.sl "Inameidxcap");esgroupx.las")de);rais
    ifitkl-!L);
lseRegExpIif (!alloNlast::
= 8  RegExpIif (!alloSttrt!= 8  RegExpIif (!alloNlastRegExpIif (!alloPtrt!= 8N te:lif ( updauest`sttorressBS { reVme) `opr 0)
   towExtheteapen .n o.eich1.uegexp_shNRegExpIif (!alloNlast  default vsttor)t{1; sttorressBS { reVme) 
  "".opt    node.uegexp_shNRegExpIif (!alloSttrtvsttora == typesttorressBS { reVme) 
+=  "ctPoi`cToS { rersttorressBIntVme) o; typessBody.node.uegexp_shNRegExpIif (!alloPtrtvsttora == typepesttorressBS { reVme) 
+=  "ctPoi`cToS { rersttorressBIntVme) o; typeUNC_HA
    ifd &&A; rais
    ifitkl-!L);
lseRegExpIif (!alloSttrtt::
= 8  Uni "ctIDSttrt!= 8  `$`!= 8  `_`!= 8  `\` RegExpUni "ctEscape&eq)  cs[+U]eich1.uegexp_shNRegExpIif (!alloSmerl.ecdefault vsttor)t{1; 1._cemerl.ecemeorrpYi.opt1._caorceU Tonode.generator = this.eat(ty11.opt1._cch  rsttorr uro/ p(aorceUi);1 sttorradva cs(aorceUi);opt    c?  ret0x5C /* \o*/t == {
  uegexp_shNRegExpUni "ctEscape&eq)  csvsttor,taorceUi == typech  rsttorressBIntVme) ca 9}
in    isRegExpIif (!alloSttrtvch. == typesttorressBIntVme) 
  ch; type
    ifd &&A; raaissttorrpYi.ecsrOf .opt
    ifitkl-!L);fC_HANGItisRegExpIif (!alloSttrtvch.t{1; AccessoisIif (!alloSttrtvch,tuhis.t   c?  ret0x24 /* $o*/til c?  ret0x5F /* _o*/ };
lseRegExpIif (!alloPtrtt::
= 8  Uni "ctIDde);inue!= 8  `$`!= 8  `_`!= 8  `\` RegExpUni "ctEscape&eq)  cs[+U]e= 8  <ZWNJ>e= 8  <ZWJ>eich1.uegexp_shNRegExpIif (!alloPerl.ecdefault vsttor)t{1; 1._cemerl.ecemeorrpYi.opt1._caorceU Tonode.generator = this.eat(ty11.opt1._cch  rsttorr uro/ p(aorceUi);1 sttorradva cs(aorceUi);opt    c?  ret0x5C /* \o*/t == {
  uegexp_shNRegExpUni "ctEscape&eq)  csvsttor,taorceUi == typech  rsttorressBIntVme) ca 9}
in    isRegExpIif (!alloPtrtvch. == typesttorressBIntVme) 
  ch; type
    ifd &&A; raaissttorrpYi.ecsrOf .opt
    ifitkl-!L);fC_HANGItisRegExpIif (!alloPtrtvch.t{1; AccessoisIif (!alloChalvch,tuhis.t   c?  ret0x24 /* $o*/til c?  ret0x5F /* _o*/t   c?  ret0x200C /* <ZWNJ>o*/t   c?  ret0x200D /* <ZWJ>o*/
L;
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-AnctEscapeeich1.uegexp_shNAnctEscape   default vsttor)t{1;      typenode.uegexp_shNBackRefere csvsttoratil type {
  uegexp_shNChalse   ntexsEscapevsttoratil type {
  uegexp_shNChalse   Escapevsttoratil typehsttorrehis.tNt == {
  uegexp_shNKGroupNlasvsttora  tyi== type
    ifd &&A; rais| thsttorrehis.tUe = typelseMake thetslastmnodage ENTV8.= 9 9
   sttorr uro/ p()t ret0x63 /* co*/at);
   s$sttorrut.sl "Inameidxuni "ctrescape"i);1 );UNC_HAsttorrut.sl "Inameidxescape"i);1 }
in
    ifitkl-!L);ich1.uegexp_shNBackRefere csi  default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt     {
  uegexp_shN);cimLlEscapevsttora == type1._c. = sttorressBIntVme) ca 9 9| thsttorrehis.tUe = types$lseFe.bSyntax    tsiifhttps://wwwor = - rternate {al.org/r = -262/8.0/#sec-anctescape types$| thni> sttorrmaxBackRefere cse{  types$s$sttorrmaxBackRefere csi  nde);););itAt);pt
    ifd &&A; );UNC_HA| thni<= sttorrnumCap"); }
P
// s == types$
    ifd &&A; );UNC_HAsttorrpYi.ecsrOf .optrais
    ifitkl-!L);ich1.uegexp_shNKGroupNlast  default vsttor)t{1;     sttorrshNo0x6B /* ko*/a == typeat inode.uegexp_shNGroupNlasvsttora == types$sttorrbackRefere csNlass (!cursttorressBS { reVme) o; types$
    ifd &&A; );UNC_HAsttorrut.sl "Inameidx.lasd refere cs")de);rais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-Chalse   Escape;ich1.uegexp_shNChalse   Escape   default vsttor)t{1; Accessov type {
  uegexp_shNde);rolEscapevsttoratil type {
  uegexp_shNCde);rolLs.  {vsttoratil type {
  uegexp_shNZerovsttoratil type {
  uegexp_shNHexEscape&eq)  csvsttoratil type {
  uegexp_shNRegExpUni "ctEscape&eq)  csvsttor,tatkl-atil typeh!sttorrshis.tUt == {
  uegexp_shNLegacyOctLlEscape&eq)  csvsttoraatil type {
  uegexp_shNIif (!tyEscapevsttora
tyi
L);ich1.uegexp_shNCde);rolLs.  {   default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt    sttorrshNo0x63 /* co*/a == typeat inode.uegexp_shNde);rolLs.  {vsttora == types$
    ifd &&A; );UNC_HAsttorrpYi.ecsrOf .optrais
    ifitkl-!L);ich1.uegexp_shNZerot  default vsttor)t{1;     sttorr uro/ p()t ret0x30 /* 0o*/t ==!is);cimLlDigitrsttorreookaheae(). == typesttorressBIntVme) 
  0; typesttorradva cs(a);1 );
    ifd &&A; rais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-de);rolEscape;ich1.uegexp_shNCe);rolEscape   default vsttor)t{1; 1._cch  rsttorr uro/ p().opt    c?  ret0x74 /* to*/at);
   sttorressBIntVme) 
  0x09; /* \to*/ typesttorradva cs(a);1 );
    ifd &&A; rais    c?  ret0x6E /* no*/at);
   sttorressBIntVme) 
  0x0A; /* \no*/ typesttorradva cs(a);1 );
    ifd &&A; rais    c?  ret0x76 /* vo*/at);
   sttorressBIntVme) 
  0x0B; /* \vo*/ typesttorradva cs(a);1 );
    ifd &&A; rais    c?  ret0x66 /* fo*/at);
   sttorressBIntVme) 
  0x0C; /* \fo*/ typesttorradva cs(a);1 );
    ifd &&A; rais    c?  ret0x72 /* ro*/at);
   sttorressBIntVme) 
  0x0D; /* \ro*/ typesttorradva cs(a);1 );
    ifd &&A; rais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-de);rolLs.  {;ich1.uegexp_shNCe);rolLs.  {   default vsttor)t{1; 1._cch  rsttorr uro/ p().opt    isde);rolLs.  {vch. == typesttorressBIntVme) 
  ch %t0x20; typesttorradva cs(a);1 );
    ifd &&A; rais
    ifitkl-!L);fC_HANGItisde);rolLs.  {vch.t{1; Accessov type(c? >ec0x41 /* Ao*/t ==c? <  0x5A /* Zo*/atil type(c? >ec0x61 /* ao*/t ==c? <  0x7A /* zo*/a
tyi
L;
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-RegExpUni "ctEscape&eq)  cseich1.uegexp_shNRegExpUni "ctEscape&eq)  cs   default vsttorteaorceUity$1     aaorceU Tretvoid 0 )oaorceU Toitkl-ca
in
 ! imerl.ecemeorrpYi.opt1._cehis.tU   dorceU ilisttorrshis.tUca
in
   sttorrshNo0x75 /* uo*/a == typeat inode.uegexp_shNFixedHexDigitsvsttor, 4a == types$
 ! leae   sttorressBIntVme) ca 9 9in
   shis.tUt ==leae >ec0xD800. ==leae <  0xDBFFety$1 );pes$
 ! leaeSuroogaorEnd   sttorrpYi.opt 9 9in
   sttorrshNo0x5C /* \o*/at ==sttorrshNo0x75 /* uo*/at == {
  uegexp_shNFixedHexDigitsvsttor, 4a == types$pes$
 ! trail   sttorressBIntVme) ca 9 9intypeat inrail >ec0xDC00. ==nrail <  0xDFFF == types$pes$pesttorressBIntVme) 
  (leae -c0xD800) *c0x400.+ inrail -c0xDC00)t+ 0x10000; types$pes$pe
    ifd &&A; ););; );UNC_HA; );UNC_HA; );sttorrpYi.ecleaeSuroogaorEnd;NC_HA; );sttorressBIntVme) 
  leaede);););itAt);pt
    ifd &&A; );UNC_HA| th types$shis.tUt = types$sttorrshNo0x7B /* {o*/atsEest(t(t {
  uegexp_shNHexDigitsvsttorat = types$sttorrshNo0x7D /* }o*/at = types$isV$lidUni "ctrsttorressBIntVme) o type == types$
    ifd &&A; );UNC_HA
   shis.tUat);
   s$sttorrut.sl "Inameidxuni "ctrescape"i);1 );UNC_HAsttorrpYi.ecsrOf .optraais
    ifitkl-!L);fC_HANGItisV$lidUni "ctrch.t{1; Accessoc? >ec0t ==c? <  0x10FFFF
L;
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-Iif (!tyEscape;ich1.uegexp_shNIif (!tyEscapet  default vsttor)t{1;     sttorrshis.tUat);
   at inode.uegexp_shNSyntaxChalse   (sttora == types$
    ifd &&A; );UNC_HA| thsttorrshNo0x2F /* /o*/a == types$sttorressBIntVme) 
  0x2F; /* /o*/ types$
    ifd &&A; );UNC_HA
    ifitkl-!in}a
in
 ! ch  rsttorr uro/ p().opt    c? !ret0x63 /* co*/e ==(!sttorrshis.tN    c? !ret0x6B /* ko*/a == typesttorressBIntVme) 
  ch; typesttorradva cs(a);1 );
    ifd &&A; raais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-);cimLlEscape;ich1.uegexp_shN);cimLlEscapet  default vsttor)t{1; sttorressBIntVme) 
  0; ty
 ! ch  rsttorr uro/ p().opt    c? >ec0x31 /* 1o*/t ==c? <  0x39 /* 9o*/at);
   do== types$sttorressBIntVme) 
  10o*$sttorressBIntVme) 
+  c? -t0x30 /* 0o*/o; types$sttorradva cs(a);1 );}tssBody.(ch  rsttorr uro/ p()) >et0x30 /* 0o*/t ==c? <  0x39 /* 9o*/a;1 );
    ifd &&A; rais
    ifitkl-!L);
lseR    ifame) se;
 d bybchalse      ptpio  re methodkte!eeded to
lsedorbidx.egaANGItof   ps that 
   mas.t s { res.
mma ChalSetN teaec0; = 8N th!nodpE_std
mma ChalSetOk
  1; = 8de)s {uctdpE_std, 
  / tt 'gaain s { resod ==ChalSetS { re
  2; = 8de)s {uctdpE_std, 
  t 'gaain s { reso
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-dhalse   ntexsEscape;ich1.uegexp_shNChalse   ntexsEscape   default vsttor)t{1; 1._cch  rsttorr uro/ p().oopt    isdhalse   ntexsEscapevch. == typesttorressBIntVme) 
  -1t 1 1 sttorradva cs(a);1 );
    ifChalSetOk!in}a
in
 ! .egaAr  rdtkl-ca1 | th typesttorrshis.tUt = type {
  generator = this.eat(ty9t = type((.egaAr  rc?  ret0x50 /* Po*/atilic?  ret0x70 /* po*/a
tyi== typesttorressBIntVme) 
  -1t 1 1 sttorradva cs(a);1 );
 ! e. onsca 9 9| th types$sttorrshNo0x7B /* {o*/atsEest(t(t(e. ons =e {
  uegexp_shNUni "ctPr 0)
 yVme) Ede(node, (sttora = = types$sttorrshNo0x7D /* }o*/a type == types$| thnegaAr  ==e. ons =retChalSetS { ree{ bsttorrut.sl "Inameidxpr 0)
   .las")d;itAt);pt
    ife. ons;1 );UNC_HAsttorrut.sl "Inameidxpr 0)
   .las")dA; raais
    ifChalSetN te!L);
fC_HANGItisdhalse   ntexsEscapevch.t{1; Accessov typec?  ret0x64 /* do*/til typec?  ret0x44 /* Do*/til typec?  ret0x73 /* so*/til typec?  ret0x53 /* So*/til typec?  ret0x77 /* wo*/til typec?  ret0x57 /* Wo*/ tyi
L;
lseUni "ctPr 0)
 yVme) Ede(node, t::
= 8  Uni "ctPr 0)
 yNlast`=`eUni "ctPr 0)
 yVme) 
= 8  L teUni "ctPr 0)
 yNlasOrVme) 
ich1.uegexp_shNUni "ctPr 0)
 yVme) Ede(node, t  default vsttor)t{1; 1._cemerl.ecemeorrpYi.o
s$lseUni "ctPr 0)
 yNlast`=`eUni "ctPr 0)
 yVme) 
  at inode.uegexp_shNUni "ctPr 0)
 yNlasvsttor)t ==sttorrshNo0x3D /* =o*/aity$1 e;1._c.n o TosttorressBS { reVme) ca 9 9| th {
  uegexp_shNUni "ctPr 0)
 yVme) (sttora == types$1._cv$luo TosttorressBS { reVme) ca 9 9(t {
  uegexp_mmlidaueUni "ctPr 0)
 yNlasAndVme) (sttor,c.n o,cv$luoo; types$
    ifChalSetOk!indin
is}
insttorrpYi.ecsrOf .o
islseLoteUni "ctPr 0)
 yNlasOrVme) 
 9| th {
  uegexp_shNLoteUni "ctPr 0)
 yNlasOrVme) vsttora == type1._c.lasOrVme)  TosttorressBS { reVme) ca 9 9classBody, "uegexp_mmlidaueUni "ctPr 0)
 yNlasOrVme) vsttor,c.lasOrVme) )A; rais
    ifChalSetN te!L);
ich1.uegexp_mmlidaueUni "ctPr 0)
 yNlasAndVme)    default vsttorte!n o,cv$luoot{1;     !hasOw vsttorruni "ctPr 0)
 ies.nonBexaryte!n o)>
(t(thisttorrut.sl "Inameidxpr 0)
   .las")d;itAt| th!sttorruni "ctPr 0)
 ies.nonBexary[.las].test(v$luoo>
(t(thisttorrut.sl "Inameidxpr 0)
   v$luo")d;itL);
ich1.uegexp_mmlidaueUni "ctPr 0)
 yNlasOrVme)  Todefault vsttorte!n oOrVme) )t{1;     sttorruni "ctPr 0)
 ies.bexary.test(!n oOrVme) ))t{.classBoChalSetOk
rais| thsttorrehis.tVt ==sttorruni "ctPr 0)
 ies.bexaryOfS { res.test(!n oOrVme) ))t{.classBoChalSetS { re
}
insttorrut.sl "Inameidxpr 0)
   .las")dAL);
lseUni "ctPr 0)
 yNlast::
= 8  Uni "ctPr 0)
 yNlasChalse   s
ich1.uegexp_shNUni "ctPr 0)
 yNlast  default vsttor)t{1; 1._cch  r0s.AtsttorressBS { reVme) 
  "".optssBody.isUni "ctPr 0)
 yNlasChalse   (ch  rsttorr uro/ p()) == typesttorressBS { reVme) 
+=  "ctPoi`cToS { rerch.t 1 1 sttorradva cs(a);1 rais
    ifsttorressBS { reVme) 
!ret""!L);
fC_HANGItisUni "ctPr 0)
 yNlasChalse   (ch.t{1; Accessoisde);rolLs.  {vch.til c?  ret0x5F /* _o*/ };
lseUni "ctPr 0)
 yVme) t::
= 8  Uni "ctPr 0)
 yVme) Chalse   s
ich1.uegexp_shNUni "ctPr 0)
 yVme)  Todefault vsttor)t{1; 1._cch  r0s.AtsttorressBS { reVme) 
  "".optssBody.isUni "ctPr 0)
 yVme) Chalse   (ch  rsttorr uro/ p()) == typesttorressBS { reVme) 
+=  "ctPoi`cToS { rerch.t 1 1 sttorradva cs(a);1 rais
    ifsttorressBS { reVme) 
!ret""!L);fC_HANGItisUni "ctPr 0)
 yVme) Chalse   (ch.t{1; AccessoisUni "ctPr 0)
 yNlasChalse   (ch.tiliis);cimLlDigitrch. };
lseLoteUni "ctPr 0)
 yNlasOrVme) t::
= 8  Uni "ctPr 0)
 yVme) Chalse   s
ich1.uegexp_shNLoteUni "ctPr 0)
 yNlasOrVme) t  default vsttor)t{1; Accesso {
  uegexp_shNUni "ctPr 0)
 yVme) (sttora!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-dhalse   ntexs;ich1.uegexp_shNChalse   ntexst  default vsttor)t{1;     sttorrshNo0x5B /* [o*/a == type1._c.egaAr  rsttorrshNo0x5E /* ^o*/a);1 );
 ! e. ons =e {
  uegexp_ctexsde);gCosvsttor)ca 9 9| th!sttorrshNo0x5D /* ]o*/a) types$histtorrut.sl "Unt  `!nLttrichalse    ctexs")d;itAt);| thnegaAr  ==e. ons =retChalSetS { ree types$histtorrut.sl "NegaArrichalse    ctexs mayt 'gaain s { res")d;itAt);
    ifd &&A; rais
    ifitkl-!L);
lsehttps://tc39.es/r = 262/#pr d-dtexsde);gCos
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-dtexsRanges;ich1.uegexp_ctexsde);gCost  default vsttor)t{1;     sttorr uro/ p()t ret0x5D /* ]o*/at{.classBoChalSetOk
rais| thsttorrehis.tVat{.classBo {
  uegexp_ctexsSetEde(node, (sttora }
inmaVeruegexp_nonEmp  dtexsRangesvsttor)ca 9
    ifChalSetOk!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-N temp  dtexsRanges
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-N temp  dtexsRangesNoDexh;ich1.uegexp_nonEmp  dtexsRangest  default vsttor)t{1; ssBody.node.uegexp_shNdtexsAnctdsttor) == type
 ! left = sttorressBIntVme) ca 9 9| thsttorrshNo0x2D /* -o*/at == {
  uegexp_shNdtexsAnctdsttor) == type);
 ! eight = sttorressBIntVme) ca 9 9HA| thsttorrehis.tUtsEl(left =ret-1t   eight =ret-1ee{  types$s$sttorrut.sl "Inameidxchalse    ctexs")d types$}a 9 9 || thleft !ret-1tsE
eight !ret-1tsE
left >
eighte{  types$s$sttorrut.sl "RangeMoutsStais. {e!n.chalse    ctexs")d types$}a 9 9n
is}
L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-dtexsAnct
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-dtexsAnctNoDexh;ich1.uegexp_shNdtexsAnctt  default vsttor)t{1; 1._cemerl.ecemeorrpYi.o
s$    sttorrshNo0x5C /* \o*/a == type    if (!e.gexp_shNntexsEscapevsttora == types$
    ifd &&A; );UNC_HA| thsttorrehis.tUe = types$lseMake thetslastmnodage ENTV8.= 9 9 |1._cch$1 f sttorr uro/ p().optC_HA| thch$1 fret0x63 /* co*/eiliisOctLlDigitrch$1ee{  types$s$sttorrut.sl "Inameidxctexs escape"i);1 ););itAt);s$sttorrut.sl "Inameidxescape"i);1 );UNC_HAsttorrpYi.ecsrOf .optraais
 ! ch  rsttorr uro/ p().opt    c? !ret0x5D /* ]o*/at{ typesttorressBIntVme) 
  ch; typesttorradva cs(a);1 );
    ifd &&A; raais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-CtexsEscape;ich1.uegexp_shNCtexsEscape   default vsttor)t{1; 1._cemerl.ecemeorrpYi.o
s$    sttorrshNo0x62 /* bo*/a == typesttorressBIntVme) 
  0x08; /* <BS>o*/ type
    ifd &&A; ra
 || thsttorrehis.tUt ==sttorrshNo0x2D /* -o*/a == typesttorressBIntVme) 
  0x2D; /* -o*/ type
    ifd &&A; ra
 || th!sttorrshis.tUt ==sttorrshNo0x63 /* co*/a == typeat inode.uegexp_shNdtexsde);rolLs.  {vsttora == types$
    ifd &&A; );UNC_HAsttorrpYi.ecsrOf .optra1; Accessov type {
  uegexp_shNChalse   ntexsEscapevsttoratil type {
  uegexp_shNChalse   Escapevsttora
tyi
L);
lsehttps://tc39.es/r = 262/#pr d-dtexsSetEde(node, 
lsehttps://tc39.es/r = 262/#pr d-dtexsUni, 
lsehttps://tc39.es/r = 262/#pr d-dtexsIrterseault 
lsehttps://tc39.es/r = 262/#pr d-dtexsSubtlse .eaeich1.uegexp_ctexsSetEde(node,    default vsttor)t{1; 1._ce. ons =eChalSetOk, subR. onsca 9at inode.uegexp_shNdtexsSetRangevsttora =;e clas
   subR. ons =e {
  uegexp_shNdtexsSetO0)
andvsttora == type
   subR. ons =retChalSetS { ree{ be. ons =eChalSetS { red;itAt);lsehttps://tc39.es/r = 262/#pr d-dtexsIrterseault 
 9 |1._cemerl.ecemeorrpYi.o 9 |ssBody.sttorrshNChars([0x26, 0x26] /*  ==*/a == types$| th types$ rsttorr uro/ p() !ret0x26 /* &o*/t =est(ttttt subR. ons =e {
  uegexp_shNdtexsSetO0)
andvsttora est(ttte{  types$s$
   subR. ons !retChalSetS { ree{ be. ons =eChalSetOkd;itAt);pt t 'gainue!1 ););itAt);s$sttorrut.sl "Inameidxchalse    !n.chalse    ctexs")d typeUNC_HA| thsttrt.!retsttorrpYiat{.classBoe. ons itAt);lsehttps://tc39.es/r = 262/#pr d-dtexsSubtlse .eae 9 |ssBody.sttorrshNChars([0x2D, 0x2D] /* --=*/a == types$| th {
  uegexp_shNdtexsSetO0)
andvsttora ==t 'gainue;itAt);s$sttorrut.sl "Inameidxchalse    !n.chalse    ctexs")d typeUNC_HA| thsttrt.!retsttorrpYiat{.classBoe. ons itAtContext);
   sttorrut.sl "Inameidxchalse    !n.chalse    ctexs")d ty}
);lsehttps://tc39.es/r = 262/#pr d-dtexsUni, 
inde.b(;; == typeat inode.uegexp_shNdtexsSetRangevsttora ==t 'gainue;itAt);subR. ons =e {
  uegexp_shNdtexsSetO0)
andvsttoraca 9 9| th!subR. onsat{.classBoe. ons itAt);
   subR. ons =retChalSetS { ree{ be. ons =eChalSetS { red;itAt}
L);
lsehttps://tc39.es/r = 262/#pr d-dtexsSetRange;ich1.uegexp_shNCtexsSetRangei  default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt     {
  uegexp_shNCtexsSetChalse   (sttora == type
 ! left = sttorressBIntVme) ca 9 9| thsttorrshNo0x2D /* -o*/at == {
  uegexp_shNdtexsSetChalse   (sttora == type);
 ! eight = sttorressBIntVme) ca 9 9HA| thleft !ret-1tsE
eight !ret-1tsE
left >
eighte{  types$s$sttorrut.sl "RangeMoutsStais. {e!n.chalse    ctexs")d types$}a 9 9s$
    ifd &&A; );UNC_HAsttorrpYi.ecsrOf .optrais
    ifitkl-!L);
lsehttps://tc39.es/r = 262/#pr d-dtexsSetO0)
and;ich1.uegexp_shNCtexsSetO0)
andt  default vsttor)t{1;      {
  uegexp_shNdtexsSetChalse   (sttora ==.classBoChalSetOk
raisAccesso {
  uegexp_shNdtexsS { reDisjefault vsttor) ility touegexp_shNNestedntexsvsttora!L);
lsehttps://tc39.es/r = 262/#pr d-Nestedntexs;ich1.uegexp_shNNestedntexs   default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt    sttorrshNo0x5B /* [o*/a == type1._c.egaAr  rsttorrshNo0x5E /* ^o*/a);1 );
 ! e. ons =e {
  uegexp_ctexsde);gCosvsttor)ca 9 9| thsttorrshNo0x5D /* ]o*/a)== types$| thnegaAr  ==e. ons =retChalSetS { ree{  types$s$sttorrut.sl "NegaArrichalse    ctexs mayt 'gaain s { res")d types$}a 9 9s$
    ife. ons;1 );UNC_HAsttorrpYi.ecsrOf .optrais    sttorrshNo0x5C /* \o*/a == type
 ! e. ons$1 f  {
  uegexp_shNChalse   ntexsEscapevsttoraca 9 9| the. ons$1 == types$
    ife. ons$1A; );UNC_HAsttorrpYi.ecsrOf .optrais
    ifnull!L);
lsehttps://tc39.es/r = 262/#pr d-dtexsS { reDisjefault ;ich1.uegexp_shNCtexsS { reDisjefault    default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt    sttorrshNChars([0x5C, 0x71] /* \qo*/a == type    sttorrshNo0x7B /* {o*/a == type);
 ! e. ons =e {
  uegexp_ctexsS { reDisjefault de);gCosvsttor)ca 9 9 || thsttorrshNo0x7D /* }o*/a == types$HA
    ife. ons;1 );s$}a 9 9nontext);
   s$lseMake thetslastmnodage ENTV8.= 9 9 |sttorrut.sl "Inameidxescape"i);1 );UNC_HAsttorrpYi.ecsrOf .optrais
    ifnull!L);
lsehttps://tc39.es/r = 262/#pr d-dtexsS { reDisjefault de);gCos
ich1.uegexp_ctexsS { reDisjefault de);gCos   default vsttor)t{1; 1._ce. ons =e {
  uegexp_ctexsS { revsttor)ca 9ssBody.sttorrshNo0x7C /* |o*/a == type     {
  uegexp_ctexsS { revsttor) =retChalSetS { ree{ be. ons =eChalSetS { red;itAt}
HA
    ife. ons;L);
lsehttps://tc39.es/r = 262/#pr d-dtexsS { re
lsehttps://tc39.es/r = 262/#pr d-NonEmp  dtexsS { re
ich1.uegexp_ctexsS { re Todefault vsttor)t{1; 1._ccounl.ec0O1; ssBody.node.uegexp_shNdtexsSetChalse   (sttora ==.counl++;t}
HA
    ifcounl.eret1 ?oChalSetOk
:eChalSetS { re!L);
lsehttps://tc39.es/r = 262/#pr d-dtexsSetChalse   ;ich1.uegexp_shNdtexsSetChalse      default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt    sttorrshNo0x5C /* \o*/a == type    = 9 9 | {
  uegexp_shNChalse   Escapevsttoratil type | {
  uegexp_shNCtexsSetReservedPefauuato vsttora type == types$
    ifd &&A; );UNC_HA
   sttorrshNo0x62 /* bo*/a == typepesttorressBIntVme) 
  0x08; /* <BS>o*/ types$
    ifd &&A; );UNC_HAsttorrpYi.ecsrOf .optHA
    ifitkl-!in}ais
 ! ch  rsttorr uro/ p().opt    c? < 0til c?  retsttorreookaheae()  ==isCtexsSetReservedDoublePefauuato Chalse   (ch. ==A
    ifitkl-9}
in    isCtexsSetSyntaxChalse   (ch. ==A
    ifitkl-9}
insttorradva cs(a);1 sttorressBIntVme) 
  ch; tyclassBod &&AL);
=sehttps://tc39.es/r = 262/#pr d-dtexsSetReservedDoublePefauuato 
fC_HANGItisdtexsSetReservedDoublePefauuato Chalse   (ch.t{1; Accessov typec?  ret0x21 /* !o*/til typec? >ec0x23 /* #o*/t ==c? <  0x26 /* &o*/til typec? >ec0x2A /* *o*/t ==c? <  0x2C /* ,o*/til typec?  ret0x2E /* .o*/til typec? >et0x3A /* :o*/t ==c? <  0x40 /* @o*/til typec?  ret0x5E /* ^o*/til typec? fret0x60 /* `o*/til typec?  ret0x7E /* ~o*/ tyi
L;
lsehttps://tc39.es/r = 262/#pr d-dtexsSetSyntaxChalse   ;fC_HANGItisdtexsSetSyntaxChalse   (ch.t{1; Accessov typec?  ret0x28 /* (o*/til typec?  ret0x29 /* )o*/til typec?  ret0x2D /* -o*/til typec?  ret0x2F /* /o*/til typec? >ec0x5B /* [o*/t ==c? <  0x5D /* ]o*/til typec? >ec0x7B /* {o*/t ==c? <  0x7D /* }o*/ tyi
L;
lsehttps://tc39.es/r = 262/#pr d-dtexsSetReservedPefauuato 
ich1.uegexp_shNCtexsSetReservedPefauuato    default vsttor)t{1; 1._cch  rsttorr uro/ p().opt    isdtexsSetReservedPefauuato vch. == typesttorressBIntVme) 
  ch; typesttorradva cs(a);1 );
    ifd &&A; rais
    ifitkl-!L);
lsehttps://tc39.es/r = 262/#pr d-dtexsSetReservedPefauuato 
fC_HANGItisdtexsSetReservedPefauuato vch.t{1; Accessov typec?  ret0x21 /* !o*/til typec?  ret0x23 /* #o*/til typec?  ret0x25 /* %o*/til typec?  ret0x26 /* &o*/til typec?  ret0x2C /* ,o*/til typec?  ret0x2D /* -o*/til typec? >et0x3A /* :o*/t ==c? <  0x3E /* >o*/til typec?  ret0x40 /* @o*/til typec?  ret0x60 /* `o*/til typec?  ret0x7E /* ~o*/ tyi
L;
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-Ctexsde);rolLs.  {;ich1.uegexp_shNCtexsde);rolLs.  {   default vsttor)t{1; 1._cch  rsttorr uro/ p().opt    is);cimLlDigitrch.til c?  ret0x5F /* _o*/ == typesttorressBIntVme) 
  ch %t0x20; typesttorradva cs(a);1 );
    ifd &&A; rais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-HexEscape&eq)  cs;ich1.uegexp_shNHexEscape&eq)  cs   default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt    sttorrshNo0x78 /* xo*/a == typeat inode.uegexp_shNFixedHexDigitsvsttor, 2a == types$
    ifd &&A; );UNC_HA| thsttorrehis.tUe = types$sttorrut.sl "Inameidxescape"i);1 );UNC_HAsttorrpYi.ecsrOf .optrais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-);cimLlDigits;ich1.uegexp_shN);cimLlDigits   default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt1._cch  r0s.AtsttorressBIntVme) 
  0; tyssBody.is);cimLlDigitrch  rsttorr uro/ p()) == typesttorressBIntVme) 
  10o*$sttorressBIntVme) 
+  c? -t0x30 /* 0o*/o; typesttorradva cs(a);1 rais
    ifsttorrpYi.!retsttrt!L);fC_HANGItis);cimLlDigitrch.t{1; Accessoc? >et0x30 /* 0o*/t ==c? <  0x39 /* 9o*/
L;
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-HexDigits;ich1.uegexp_shNHexDigits   default vsttor)t{1; 1._cemerl.ecemeorrpYi.opt1._cch  r0s.AtsttorressBIntVme) 
  0; tyssBody.isHexDigitrch  rsttorr uro/ p()) == typesttorressBIntVme) 
  16o*$sttorressBIntVme) 
+ hexToIntrch.t 1 1 sttorradva cs(a);1 rais
    ifsttorrpYi.!retsttrt!L);fC_HANGItisHexDigitrch.t{1; Accessov type(c? >ec0x30 /* 0o*/t ==c? <  0x39 /* 9o*/atil type(c? >ec0x41 /* Ao*/t ==c? <  0x46 /* Fo*/atil type(c? >ec0x61 /* ao*/t ==c? <  0x66 /* fo*/a tyi
L;fC_HANGIthexToIntrch.t{1;     c? >ec0x41 /* Ao*/t ==c? <  0x46 /* Fo*/at{;1 );
    if10
+  c? -t0x41 /* Ao*/)A; rais    c? >ec0x61 /* ao*/t ==c? <  0x66 /* fo*/at{;1 );
    if10
+  c? -t0x61 /* ao*/)A; rais
    ifc? -t0x30 /* 0o*/
L;
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-an.arB-LegacyOctLlEscape&eq)  cs
lseAllows only 0-377(octLl) i.e. 0-255(d;cimLl).eich1.uegexp_shNLegacyOctLlEscape&eq)  cst  default vsttor)t{1;      {
  uegexp_shNOctLlDigitrsttora == type
 ! n1 f sttorressBIntVme) ca 9 9| th {
  uegexp_shNOctLlDigitrsttora == typepe
 ! n2 = sttorressBIntVme) ca 9 9HA| thn1 <  3t == {
  uegexp_shNOctLlDigitrsttora == typepepesttorressBIntVme) 
  n1 * 64
+ n2 * 8
+ sttorressBIntVme) ca 9 9HAnontext);
   s$pesttorressBIntVme) 
  n1 * 8
+ n2d types$}a 9 9nontext);
   s$sttorressBIntVme) 
  n1);1 );UNC_HA
    ifd &&A; rais
    ifitkl-!L);
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-OctLlDigiteich1.uegexp_shNOctLlDigit   default vsttor)t{1; 1._cch  rsttorr uro/ p().opt    isOctLlDigitrch. == typesttorressBIntVme) 
  ch -t0x30; /* 0o*/
typesttorradva cs(a);1 );
    ifd &&A; raissttorressBIntVme) 
  0; ty
    ifitkl-!L);fC_HANGItisOctLlDigitrch.t{1; Accessoc? >et0x30 /* 0o*/t ==c? <  0x37 /* 7o*/
L;
lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-Hex4Digits;lsehttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-HexDigit
lseAnd HexDigit HexDigit iifhttps://wwwor = - rternate {al.org/r = -262/8.0/#pr d-HexEscape&eq)  cs;ich1.uegexp_shNFixedHexDigits Todefault vsttorteitch ? == ty1._cemerl.ecemeorrpYi.optsttorressBIntVme) 
  0; tyde.b(mma h.ec0; h.<
ltch ?; ++i == type
 ! ch  rsttorr uro/ p().opt 9| th!isHexDigitrch.e = types$sttorrpYi.ecsrOf .optHAHA
    ifitkl-!in);UNC_HAsttorressBIntVme) 
  16o*$sttorressBIntVme) 
+ hexToIntrch.t 1 1 sttorradva cs(a);1 rais
    ifd &&AL);
=seObject typee;
 d ratrepresent tokens.8N te that normLlly, tokens
=sesimply extyp asxpr 0)
 ies on thetpE_str object. Tf ( is only
=se;
 d de.bthetonToken cLllback andtthetexternal tokenizer.;od ==Token Todefault =Token(pe = ty {
  typee= p type; ty {
  v$luo Top v$luo; ty {
  emerl.ecp.srOf .opt {
  endt  p end.opt    p generatolocate {s>
(t(thi {
  loc
  new SourceLocate {(p,cp.srOf Loc, p endLoc)d;itAt| thp generatoranges>
(t(thi {
  rangei  [p.srOf , p end]d;itL);
=se##=Tokenizer;od ==pp   PE_str.pr totype; 
=seMove ratthet.art token;
ic..art Todefault vignortEscape&eq)  csInKeywordot{1;     !ignortEscape&eq)  csInKeywordt == {
  type.keywordt == {
   'gaainsEsc>
(t(thi {
  ra.slRecovergErr( {
  emerl, "Escape seq)  cstiifkeywordt"
+  {
  type.keyword)d;itAt| th {
  generatoonToken>
(t(thi {
  generatoonToken(new Token( {
 ))d;itopt {
  essBTokEnd    {
  end;opt {
  essBTokSmerl.ec {
  emerl;opt {
  essBTokEndLoc    {
  endLoc;opt {
  essBTokSmerlLoc    {
  srOf Loc;opt {
  .artToken()dAL);
ic.getToken Todefault (e = ty {
  .art()ca 9
    ifnew Token( {
 )tL);
=seIf we'rstiifan ES6 environment,
maketpE_str( itergErr
| th ypeof Symbol
!ret"undefined">
(t{=pp[Symbol.itergtor] Todefault (e = tys$
 ! t{
 $1$1 f  {
 .o
s$ 9
    if= types$.art:odefault =( == typepepe
 ! token Tot{
 $1$1.getToken().optC_HA 9
    if= types$$$$$done:lioken typee=rettype $1.eof, types$$$$$v$luo:lioken types$$$}a 9 9s$}a 9 9n
is}d;ito=seToggodys { ct mode. Re-readstthet.art numb { or s { re ratpleass
lsepeda (!c tests (`";
 ys { ct"; 010;` should dail).e
lseR ad ao  relelioken, updau re rhetpE_str object'slioken-relaArr
lsepr 0)
 ies.;
ic..artToken Todefault (e = ty
 ! curde);gxl.ec {
  curde);gxl().opt    !curde);gxl.|| !curde);gxl.preserveSpacse{   {
  skipSpacs()d;itopt {
  smerl.ec {
  pYi.opt     {
  generatolocate {s>{   {
  smerlLoc    {
  curPosiult (ed;itAt| th {
  pYi.>   {
  input.itch ? ==sAccesso {
  finishToken( ype $1.eof) ra
 || thcurde);gxl.override ==sAccessocurde);gxl.override( {
 );itAtntext)= {
  ueadToken( {
 .fullChalCodeAtPos())d;itL);
ic ueadToken Todefault ( "cte = ty=seIif (!allo or keyword. '\uXXXX' seq)  css arstallow d in ty=seiif (!allos, so '\'talso dispas.tes ratthat.opt    isIif (!alloSttrtvc"ct,e {
  generator = this.eat(ty6.til c"ctr=ret92 /* '\'t*/a type{.classBo {
  ueadWord()tra1; Accesso {
  getTokenFromC"ctrc"ctetL);
ic fullChalCodeAtPos Todefault (e = ty
 ! c"ctr=  {
  input.chalCodeAth {
  pYi).opt    c"ctr<  0xd7fftil c"ctr>et0xdc00)t=sAccessoc"ctr}ais
 ! ngxl.ec {
  input.chalCodeAth {
  pYi
+ 1)ca 9
    ifnexl.<  0xdbfftil nexl.>et0xe000 ?oc"ctr:  c"ctr<< 10)t+ nexl.-t0x35fdc00tL);
ic skipBlockComment Todefault (e = ty
 ! smerlLoc    {
  generatoonComment  == {
   urPosiult (ed ty1._cemerl.ec {
  pYi, end    {
  input.expexOf("*/",  {
  pYi
+= 2).opt    end  ret-1e{ i {
  ra.slh {
  pYi
- 2, "Unt  `!nLttricomment")d;itAt {
  pYi
= end + 2.opt     {
  generatolocate {s>{  typede.b(mma nexlBueak
  (void 0), pYi.ecsrOf .thnexlBueak
  nexlLineBueak( {
  input, pYi,  {
  pYi)) > -1t == typepe++ {
   urLine.optC_HApYi.ec {
  eineSmerl.ecnexlBueak);1 );UNC_itAt| th {
  generatoonComment>
(t(thi {
  generatoonComment(d &&,  {
  input.slicsvsttrl.+ 2, end), emerl,  {
  pYi, types$$$$$$$$$$$$$$$$$$$$$$srOf Loc,  {
   urPosiult (e)d;itL);
ic skipLineComment Todefault (srOf Skip == ty1._cemerl.ec {
  pYi.opt
 ! smerlLoc    {
  generatoonComment  == {
   urPosiult (ed ty1._cch  r {
  input.chalCodeAth {
  pYi
+ecsrOf Skip O1; ssBody.node.pYi
<  {
  input.itch ?t ==!isNewLinerch.e = typech  r {
  input.chalCodeAth++ {
  pYi).optitAt| th {
  generatoonComment>
(t(thi {
  generatoonComment(itkl-,  {
  input.slicsvsttrl.+ srOf Skip,  {
  pYi), emerl,  {
  pYi, types$$$$$$$$$$$$$$$$$$$$$$srOf Loc,  {
   urPosiult (e)d;itL);
= 8dalltriat thetsttrl.of rhetpE_st andtaf  { ev {ylioken  Skips
=sessBtespacs andtcommenti, and.;
ic skipSpacs Todefault (e = tyloop: ssBody.node.pYi
<  {
  input.itch ? == type
 ! ch  r {
  input.chalCodeAth {
  pYi).opts$shis.t rch.t{1; pecass 32:ecass 160:y=se' ' typepe++ {
  pYi.opt 9 9bueak1; pecass 13:a 9 9HA| th {
  input.chalCodeAth {
  pYi
+ 1).eret10 == typepepe++ {
  pYi.opt 9 9}1; pecass 10:ecass 8232:ecass 8233:a 9 9HA++ {
  pYi.opt 9 9     {
  generatolocate {s>{  typepepe++ {
   urLine.optC_HA c {
  eineSmerl.ec {
  pYi.opt 9 9}1; pe 9bueak1; pecass 47:y=se'/' typepeshis.t r {
  input.chalCodeAth {
  pYi
+ 1)>{  typepecass 42:y=se'*'optC_HA c {
  skipBlockComment().optC_HA 9bueak1; pepecass 47:optC_HA c {
  skipLineComment(2).optC_HA 9bueak1; pepedefault:optC_HA 9bueakyloopopt 9 9}1; pe 9bueak1; pedefault:optC_HA    c? > 8t ==c? < 14til c? >et5760t ==nonASCIIssBtespacs.test(S { re.fromChalCoderch.e == typepepe++ {
  pYi.opt 9 9}ontext);
   s$pebueakyloopopt 9 9}1; peitAt}
L);
lsedalltriat thetend of ev {ylioken  S ps `end`, `v$l`, and
lsemaigaains `ce);gxl` andt`exprAllow d`, and skipstthetspacs af   ;estthetioken, satthattthet.art one'st`sttrl` willApYigaiat the;esteight posiult .;
ic finishToken Todefault ( ype,cv$le = ty {
  end    {
  pYi.opt     {
  generatolocate {s>{   {
  endLoc    {
  curPosiult (ed;itAtd ==prevTypee=  {
  type;opt {
  typee= type; ty {
  v$luo Tov$l;topt {
  updauede);gxl(prevType)dAL);
lse###=Token uead re!o=seTf ( is thetdefault =thattis calltriratfes.t thet.art token. It
lseis somewhattobscure,cbeca;
 yit workse!n.chalse    codes rathe ;estthan.chalse   i, andcbeca;
 y 0)
ato  pio  re hascbeen ineined
lseigaoyit.
ls
lseAlle!n.thet.lastof  peed.
ls
ic ueadToken_dot Todefault (e = ty
 ! ngxl.ec {
  input.chalCodeAth {
  pYi
+ 1)ca 9| thnexl.>et48t ==nexl.<  57at{.classBo {
  ueadNumb {(uhis.t}ais
 ! ngxl2.ec {
  input.chalCodeAth {
  pYi
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 